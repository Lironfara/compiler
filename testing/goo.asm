;;; prologue-1.asm
;;; The first part of the standard prologue for compiled programs
;;;
;;; Programmer: Mayer Goldberg, 2023

%define T_void 				0
%define T_nil 				1
%define T_char 				2
%define T_string 			3
%define T_closure 			4
%define T_undefined			5
%define T_boolean 			8
%define T_boolean_false 		(T_boolean | 1)
%define T_boolean_true 			(T_boolean | 2)
%define T_number 			16
%define T_integer			(T_number | 1)
%define T_fraction 			(T_number | 2)
%define T_real 				(T_number | 3)
%define T_collection 			32
%define T_pair 				(T_collection | 1)
%define T_vector 			(T_collection | 2)
%define T_symbol 			64
%define T_interned_symbol		(T_symbol | 1)
%define T_uninterned_symbol		(T_symbol | 2)

%define SOB_CHAR_VALUE(reg) 		byte [reg + 1]
%define SOB_PAIR_CAR(reg)		qword [reg + 1]
%define SOB_PAIR_CDR(reg)		qword [reg + 1 + 8]
%define SOB_STRING_LENGTH(reg)		qword [reg + 1]
%define SOB_VECTOR_LENGTH(reg)		qword [reg + 1]
%define SOB_CLOSURE_ENV(reg)		qword [reg + 1]
%define SOB_CLOSURE_CODE(reg)		qword [reg + 1 + 8]

%define OLD_RBP 			qword [rbp]
%define RET_ADDR 			qword [rbp + 8 * 1]
%define ENV 				qword [rbp + 8 * 2]
%define COUNT 				qword [rbp + 8 * 3]
%define PARAM(n) 			qword [rbp + 8 * (4 + n)]
%define AND_KILL_FRAME(n)		(8 * (2 + n))

%define MAGIC				496351

%macro ENTER 0
	enter 0, 0
	and rsp, ~15
%endmacro

%macro LEAVE 0
	leave
%endmacro

%macro assert_type 2
        cmp byte [%1], %2
        jne L_error_incorrect_type
%endmacro

%define assert_void(reg)		assert_type reg, T_void
%define assert_nil(reg)			assert_type reg, T_nil
%define assert_char(reg)		assert_type reg, T_char
%define assert_string(reg)		assert_type reg, T_string
%define assert_symbol(reg)		assert_type reg, T_symbol
%define assert_interned_symbol(reg)	assert_type reg, T_interned_symbol
%define assert_uninterned_symbol(reg)	assert_type reg, T_uninterned_symbol
%define assert_closure(reg)		assert_type reg, T_closure
%define assert_boolean(reg)		assert_type reg, T_boolean
%define assert_integer(reg)		assert_type reg, T_integer
%define assert_fraction(reg)		assert_type reg, T_fraction
%define assert_real(reg)		assert_type reg, T_real
%define assert_pair(reg)		assert_type reg, T_pair
%define assert_vector(reg)		assert_type reg, T_vector

%define sob_void			(L_constants + 0)
%define sob_nil				(L_constants + 1)
%define sob_boolean_false		(L_constants + 2)
%define sob_boolean_true		(L_constants + 3)
%define sob_char_nul			(L_constants + 4)

%define bytes(n)			(n)
%define kbytes(n) 			(bytes(n) << 10)
%define mbytes(n) 			(kbytes(n) << 10)
%define gbytes(n) 			(mbytes(n) << 10)

section .data
L_constants:
	; L_constants + 0:
	db T_void
	; L_constants + 1:
	db T_nil
	; L_constants + 2:
	db T_boolean_false
	; L_constants + 3:
	db T_boolean_true
	; L_constants + 4:
	db T_char, 0x00	; #\nul
	; L_constants + 6:
	db T_string	; "null?"
	dq 5
	db 0x6E, 0x75, 0x6C, 0x6C, 0x3F
	; L_constants + 20:
	db T_string	; "pair?"
	dq 5
	db 0x70, 0x61, 0x69, 0x72, 0x3F
	; L_constants + 34:
	db T_string	; "void?"
	dq 5
	db 0x76, 0x6F, 0x69, 0x64, 0x3F
	; L_constants + 48:
	db T_string	; "char?"
	dq 5
	db 0x63, 0x68, 0x61, 0x72, 0x3F
	; L_constants + 62:
	db T_string	; "string?"
	dq 7
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3F
	; L_constants + 78:
	db T_string	; "interned-symbol?"
	dq 16
	db 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E, 0x65, 0x64
	db 0x2D, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x3F
	; L_constants + 103:
	db T_string	; "vector?"
	dq 7
	db 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x3F
	; L_constants + 119:
	db T_string	; "procedure?"
	dq 10
	db 0x70, 0x72, 0x6F, 0x63, 0x65, 0x64, 0x75, 0x72
	db 0x65, 0x3F
	; L_constants + 138:
	db T_string	; "real?"
	dq 5
	db 0x72, 0x65, 0x61, 0x6C, 0x3F
	; L_constants + 152:
	db T_string	; "fraction?"
	dq 9
	db 0x66, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E
	db 0x3F
	; L_constants + 170:
	db T_string	; "boolean?"
	dq 8
	db 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x3F
	; L_constants + 187:
	db T_string	; "number?"
	dq 7
	db 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x3F
	; L_constants + 203:
	db T_string	; "collection?"
	dq 11
	db 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69
	db 0x6F, 0x6E, 0x3F
	; L_constants + 223:
	db T_string	; "cons"
	dq 4
	db 0x63, 0x6F, 0x6E, 0x73
	; L_constants + 236:
	db T_string	; "display-sexpr"
	dq 13
	db 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x2D
	db 0x73, 0x65, 0x78, 0x70, 0x72
	; L_constants + 258:
	db T_string	; "write-char"
	dq 10
	db 0x77, 0x72, 0x69, 0x74, 0x65, 0x2D, 0x63, 0x68
	db 0x61, 0x72
	; L_constants + 277:
	db T_string	; "car"
	dq 3
	db 0x63, 0x61, 0x72
	; L_constants + 289:
	db T_string	; "cdr"
	dq 3
	db 0x63, 0x64, 0x72
	; L_constants + 301:
	db T_string	; "string-length"
	dq 13
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x6C
	db 0x65, 0x6E, 0x67, 0x74, 0x68
	; L_constants + 323:
	db T_string	; "vector-length"
	dq 13
	db 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x2D, 0x6C
	db 0x65, 0x6E, 0x67, 0x74, 0x68
	; L_constants + 345:
	db T_string	; "real->integer"
	dq 13
	db 0x72, 0x65, 0x61, 0x6C, 0x2D, 0x3E, 0x69, 0x6E
	db 0x74, 0x65, 0x67, 0x65, 0x72
	; L_constants + 367:
	db T_string	; "exit"
	dq 4
	db 0x65, 0x78, 0x69, 0x74
	; L_constants + 380:
	db T_string	; "integer->real"
	dq 13
	db 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2D
	db 0x3E, 0x72, 0x65, 0x61, 0x6C
	; L_constants + 402:
	db T_string	; "fraction->real"
	dq 14
	db 0x66, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E
	db 0x2D, 0x3E, 0x72, 0x65, 0x61, 0x6C
	; L_constants + 425:
	db T_string	; "char->integer"
	dq 13
	db 0x63, 0x68, 0x61, 0x72, 0x2D, 0x3E, 0x69, 0x6E
	db 0x74, 0x65, 0x67, 0x65, 0x72
	; L_constants + 447:
	db T_string	; "integer->char"
	dq 13
	db 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2D
	db 0x3E, 0x63, 0x68, 0x61, 0x72
	; L_constants + 469:
	db T_string	; "trng"
	dq 4
	db 0x74, 0x72, 0x6E, 0x67
	; L_constants + 482:
	db T_string	; "zero?"
	dq 5
	db 0x7A, 0x65, 0x72, 0x6F, 0x3F
	; L_constants + 496:
	db T_string	; "integer?"
	dq 8
	db 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x3F
	; L_constants + 513:
	db T_string	; "__bin-apply"
	dq 11
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x61, 0x70
	db 0x70, 0x6C, 0x79
	; L_constants + 533:
	db T_string	; "__bin-add-rr"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x61, 0x64
	db 0x64, 0x2D, 0x72, 0x72
	; L_constants + 554:
	db T_string	; "__bin-sub-rr"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x73, 0x75
	db 0x62, 0x2D, 0x72, 0x72
	; L_constants + 575:
	db T_string	; "__bin-mul-rr"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x6D, 0x75
	db 0x6C, 0x2D, 0x72, 0x72
	; L_constants + 596:
	db T_string	; "__bin-div-rr"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x64, 0x69
	db 0x76, 0x2D, 0x72, 0x72
	; L_constants + 617:
	db T_string	; "__bin-add-qq"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x61, 0x64
	db 0x64, 0x2D, 0x71, 0x71
	; L_constants + 638:
	db T_string	; "__bin-sub-qq"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x73, 0x75
	db 0x62, 0x2D, 0x71, 0x71
	; L_constants + 659:
	db T_string	; "__bin-mul-qq"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x6D, 0x75
	db 0x6C, 0x2D, 0x71, 0x71
	; L_constants + 680:
	db T_string	; "__bin-div-qq"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x64, 0x69
	db 0x76, 0x2D, 0x71, 0x71
	; L_constants + 701:
	db T_string	; "__bin-add-zz"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x61, 0x64
	db 0x64, 0x2D, 0x7A, 0x7A
	; L_constants + 722:
	db T_string	; "__bin-sub-zz"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x73, 0x75
	db 0x62, 0x2D, 0x7A, 0x7A
	; L_constants + 743:
	db T_string	; "__bin-mul-zz"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x6D, 0x75
	db 0x6C, 0x2D, 0x7A, 0x7A
	; L_constants + 764:
	db T_string	; "__bin-div-zz"
	dq 12
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x64, 0x69
	db 0x76, 0x2D, 0x7A, 0x7A
	; L_constants + 785:
	db T_string	; "error"
	dq 5
	db 0x65, 0x72, 0x72, 0x6F, 0x72
	; L_constants + 799:
	db T_string	; "__bin-less-than-rr"
	dq 18
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x6C, 0x65
	db 0x73, 0x73, 0x2D, 0x74, 0x68, 0x61, 0x6E, 0x2D
	db 0x72, 0x72
	; L_constants + 826:
	db T_string	; "__bin-less-than-qq"
	dq 18
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x6C, 0x65
	db 0x73, 0x73, 0x2D, 0x74, 0x68, 0x61, 0x6E, 0x2D
	db 0x71, 0x71
	; L_constants + 853:
	db T_string	; "__bin-less-than-zz"
	dq 18
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x6C, 0x65
	db 0x73, 0x73, 0x2D, 0x74, 0x68, 0x61, 0x6E, 0x2D
	db 0x7A, 0x7A
	; L_constants + 880:
	db T_string	; "__bin-equal-rr"
	dq 14
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x65, 0x71
	db 0x75, 0x61, 0x6C, 0x2D, 0x72, 0x72
	; L_constants + 903:
	db T_string	; "__bin-equal-qq"
	dq 14
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x65, 0x71
	db 0x75, 0x61, 0x6C, 0x2D, 0x71, 0x71
	; L_constants + 926:
	db T_string	; "__bin-equal-zz"
	dq 14
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x2D, 0x65, 0x71
	db 0x75, 0x61, 0x6C, 0x2D, 0x7A, 0x7A
	; L_constants + 949:
	db T_string	; "quotient"
	dq 8
	db 0x71, 0x75, 0x6F, 0x74, 0x69, 0x65, 0x6E, 0x74
	; L_constants + 966:
	db T_string	; "remainder"
	dq 9
	db 0x72, 0x65, 0x6D, 0x61, 0x69, 0x6E, 0x64, 0x65
	db 0x72
	; L_constants + 984:
	db T_string	; "set-car!"
	dq 8
	db 0x73, 0x65, 0x74, 0x2D, 0x63, 0x61, 0x72, 0x21
	; L_constants + 1001:
	db T_string	; "set-cdr!"
	dq 8
	db 0x73, 0x65, 0x74, 0x2D, 0x63, 0x64, 0x72, 0x21
	; L_constants + 1018:
	db T_string	; "string-ref"
	dq 10
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x72
	db 0x65, 0x66
	; L_constants + 1037:
	db T_string	; "vector-ref"
	dq 10
	db 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x2D, 0x72
	db 0x65, 0x66
	; L_constants + 1056:
	db T_string	; "vector-set!"
	dq 11
	db 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x2D, 0x73
	db 0x65, 0x74, 0x21
	; L_constants + 1076:
	db T_string	; "string-set!"
	dq 11
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x73
	db 0x65, 0x74, 0x21
	; L_constants + 1096:
	db T_string	; "make-vector"
	dq 11
	db 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x76, 0x65, 0x63
	db 0x74, 0x6F, 0x72
	; L_constants + 1116:
	db T_string	; "make-string"
	dq 11
	db 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x73, 0x74, 0x72
	db 0x69, 0x6E, 0x67
	; L_constants + 1136:
	db T_string	; "numerator"
	dq 9
	db 0x6E, 0x75, 0x6D, 0x65, 0x72, 0x61, 0x74, 0x6F
	db 0x72
	; L_constants + 1154:
	db T_string	; "denominator"
	dq 11
	db 0x64, 0x65, 0x6E, 0x6F, 0x6D, 0x69, 0x6E, 0x61
	db 0x74, 0x6F, 0x72
	; L_constants + 1174:
	db T_string	; "eq?"
	dq 3
	db 0x65, 0x71, 0x3F
	; L_constants + 1186:
	db T_string	; "__integer-to-fracti...
	dq 21
	db 0x5F, 0x5F, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65
	db 0x72, 0x2D, 0x74, 0x6F, 0x2D, 0x66, 0x72, 0x61
	db 0x63, 0x74, 0x69, 0x6F, 0x6E
	; L_constants + 1216:
	db T_string	; "logand"
	dq 6
	db 0x6C, 0x6F, 0x67, 0x61, 0x6E, 0x64
	; L_constants + 1231:
	db T_string	; "logor"
	dq 5
	db 0x6C, 0x6F, 0x67, 0x6F, 0x72
	; L_constants + 1245:
	db T_string	; "logxor"
	dq 6
	db 0x6C, 0x6F, 0x67, 0x78, 0x6F, 0x72
	; L_constants + 1260:
	db T_string	; "lognot"
	dq 6
	db 0x6C, 0x6F, 0x67, 0x6E, 0x6F, 0x74
	; L_constants + 1275:
	db T_string	; "ash"
	dq 3
	db 0x61, 0x73, 0x68
	; L_constants + 1287:
	db T_string	; "symbol?"
	dq 7
	db 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x3F
	; L_constants + 1303:
	db T_string	; "uninterned-symbol?"
	dq 18
	db 0x75, 0x6E, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E
	db 0x65, 0x64, 0x2D, 0x73, 0x79, 0x6D, 0x62, 0x6F
	db 0x6C, 0x3F
	; L_constants + 1330:
	db T_string	; "gensym?"
	dq 7
	db 0x67, 0x65, 0x6E, 0x73, 0x79, 0x6D, 0x3F
	; L_constants + 1346:
	db T_string	; "gensym"
	dq 6
	db 0x67, 0x65, 0x6E, 0x73, 0x79, 0x6D
	; L_constants + 1361:
	db T_string	; "frame"
	dq 5
	db 0x66, 0x72, 0x61, 0x6D, 0x65
	; L_constants + 1375:
	db T_string	; "break"
	dq 5
	db 0x62, 0x72, 0x65, 0x61, 0x6B
	; L_constants + 1389:
	db T_string	; "boolean-false?"
	dq 14
	db 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2D
	db 0x66, 0x61, 0x6C, 0x73, 0x65, 0x3F
	; L_constants + 1412:
	db T_string	; "boolean-true?"
	dq 13
	db 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2D
	db 0x74, 0x72, 0x75, 0x65, 0x3F
	; L_constants + 1434:
	db T_string	; "primitive?"
	dq 10
	db 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76
	db 0x65, 0x3F
	; L_constants + 1453:
	db T_string	; "length"
	dq 6
	db 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68
	; L_constants + 1468:
	db T_string	; "make-list"
	dq 9
	db 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x6C, 0x69, 0x73
	db 0x74
	; L_constants + 1486:
	db T_string	; "return"
	dq 6
	db 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E
	; L_constants + 1501:
	db T_string	; "caar"
	dq 4
	db 0x63, 0x61, 0x61, 0x72
	; L_constants + 1514:
	db T_string	; "cadr"
	dq 4
	db 0x63, 0x61, 0x64, 0x72
	; L_constants + 1527:
	db T_string	; "cdar"
	dq 4
	db 0x63, 0x64, 0x61, 0x72
	; L_constants + 1540:
	db T_string	; "cddr"
	dq 4
	db 0x63, 0x64, 0x64, 0x72
	; L_constants + 1553:
	db T_string	; "caaar"
	dq 5
	db 0x63, 0x61, 0x61, 0x61, 0x72
	; L_constants + 1567:
	db T_string	; "caadr"
	dq 5
	db 0x63, 0x61, 0x61, 0x64, 0x72
	; L_constants + 1581:
	db T_string	; "cadar"
	dq 5
	db 0x63, 0x61, 0x64, 0x61, 0x72
	; L_constants + 1595:
	db T_string	; "caddr"
	dq 5
	db 0x63, 0x61, 0x64, 0x64, 0x72
	; L_constants + 1609:
	db T_string	; "cdaar"
	dq 5
	db 0x63, 0x64, 0x61, 0x61, 0x72
	; L_constants + 1623:
	db T_string	; "cdadr"
	dq 5
	db 0x63, 0x64, 0x61, 0x64, 0x72
	; L_constants + 1637:
	db T_string	; "cddar"
	dq 5
	db 0x63, 0x64, 0x64, 0x61, 0x72
	; L_constants + 1651:
	db T_string	; "cdddr"
	dq 5
	db 0x63, 0x64, 0x64, 0x64, 0x72
	; L_constants + 1665:
	db T_string	; "caaaar"
	dq 6
	db 0x63, 0x61, 0x61, 0x61, 0x61, 0x72
	; L_constants + 1680:
	db T_string	; "caaadr"
	dq 6
	db 0x63, 0x61, 0x61, 0x61, 0x64, 0x72
	; L_constants + 1695:
	db T_string	; "caadar"
	dq 6
	db 0x63, 0x61, 0x61, 0x64, 0x61, 0x72
	; L_constants + 1710:
	db T_string	; "caaddr"
	dq 6
	db 0x63, 0x61, 0x61, 0x64, 0x64, 0x72
	; L_constants + 1725:
	db T_string	; "cadaar"
	dq 6
	db 0x63, 0x61, 0x64, 0x61, 0x61, 0x72
	; L_constants + 1740:
	db T_string	; "cadadr"
	dq 6
	db 0x63, 0x61, 0x64, 0x61, 0x64, 0x72
	; L_constants + 1755:
	db T_string	; "caddar"
	dq 6
	db 0x63, 0x61, 0x64, 0x64, 0x61, 0x72
	; L_constants + 1770:
	db T_string	; "cadddr"
	dq 6
	db 0x63, 0x61, 0x64, 0x64, 0x64, 0x72
	; L_constants + 1785:
	db T_string	; "cdaaar"
	dq 6
	db 0x63, 0x64, 0x61, 0x61, 0x61, 0x72
	; L_constants + 1800:
	db T_string	; "cdaadr"
	dq 6
	db 0x63, 0x64, 0x61, 0x61, 0x64, 0x72
	; L_constants + 1815:
	db T_string	; "cdadar"
	dq 6
	db 0x63, 0x64, 0x61, 0x64, 0x61, 0x72
	; L_constants + 1830:
	db T_string	; "cdaddr"
	dq 6
	db 0x63, 0x64, 0x61, 0x64, 0x64, 0x72
	; L_constants + 1845:
	db T_string	; "cddaar"
	dq 6
	db 0x63, 0x64, 0x64, 0x61, 0x61, 0x72
	; L_constants + 1860:
	db T_string	; "cddadr"
	dq 6
	db 0x63, 0x64, 0x64, 0x61, 0x64, 0x72
	; L_constants + 1875:
	db T_string	; "cdddar"
	dq 6
	db 0x63, 0x64, 0x64, 0x64, 0x61, 0x72
	; L_constants + 1890:
	db T_string	; "cddddr"
	dq 6
	db 0x63, 0x64, 0x64, 0x64, 0x64, 0x72
	; L_constants + 1905:
	db T_string	; "list?"
	dq 5
	db 0x6C, 0x69, 0x73, 0x74, 0x3F
	; L_constants + 1919:
	db T_string	; "list"
	dq 4
	db 0x6C, 0x69, 0x73, 0x74
	; L_constants + 1932:
	db T_string	; "not"
	dq 3
	db 0x6E, 0x6F, 0x74
	; L_constants + 1944:
	db T_string	; "rational?"
	dq 9
	db 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C
	db 0x3F
	; L_constants + 1962:
	db T_string	; "list*"
	dq 5
	db 0x6C, 0x69, 0x73, 0x74, 0x2A
	; L_constants + 1976:
	db T_string	; "whatever"
	dq 8
	db 0x77, 0x68, 0x61, 0x74, 0x65, 0x76, 0x65, 0x72
	; L_constants + 1993:
	db T_interned_symbol	; whatever
	dq L_constants + 1976
	; L_constants + 2002:
	db T_string	; "apply"
	dq 5
	db 0x61, 0x70, 0x70, 0x6C, 0x79
	; L_constants + 2016:
	db T_string	; "ormap"
	dq 5
	db 0x6F, 0x72, 0x6D, 0x61, 0x70
	; L_constants + 2030:
	db T_string	; "map"
	dq 3
	db 0x6D, 0x61, 0x70
	; L_constants + 2042:
	db T_string	; "andmap"
	dq 6
	db 0x61, 0x6E, 0x64, 0x6D, 0x61, 0x70
	; L_constants + 2057:
	db T_string	; "reverse"
	dq 7
	db 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65
	; L_constants + 2073:
	db T_string	; "fold-left"
	dq 9
	db 0x66, 0x6F, 0x6C, 0x64, 0x2D, 0x6C, 0x65, 0x66
	db 0x74
	; L_constants + 2091:
	db T_string	; "append"
	dq 6
	db 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64
	; L_constants + 2106:
	db T_string	; "fold-right"
	dq 10
	db 0x66, 0x6F, 0x6C, 0x64, 0x2D, 0x72, 0x69, 0x67
	db 0x68, 0x74
	; L_constants + 2125:
	db T_string	; "+"
	dq 1
	db 0x2B
	; L_constants + 2135:
	db T_integer	; 0
	dq 0
	; L_constants + 2144:
	db T_string	; "__bin_integer_to_fr...
	dq 25
	db 0x5F, 0x5F, 0x62, 0x69, 0x6E, 0x5F, 0x69, 0x6E
	db 0x74, 0x65, 0x67, 0x65, 0x72, 0x5F, 0x74, 0x6F
	db 0x5F, 0x66, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6F
	db 0x6E
	; L_constants + 2178:
	db T_interned_symbol	; +
	dq L_constants + 2125
	; L_constants + 2187:
	db T_string	; "all arguments need ...
	dq 32
	db 0x61, 0x6C, 0x6C, 0x20, 0x61, 0x72, 0x67, 0x75
	db 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x6E, 0x65
	db 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65
	db 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x73
	; L_constants + 2228:
	db T_string	; "-"
	dq 1
	db 0x2D
	; L_constants + 2238:
	db T_string	; "real"
	dq 4
	db 0x72, 0x65, 0x61, 0x6C
	; L_constants + 2251:
	db T_interned_symbol	; -
	dq L_constants + 2228
	; L_constants + 2260:
	db T_string	; "*"
	dq 1
	db 0x2A
	; L_constants + 2270:
	db T_integer	; 1
	dq 1
	; L_constants + 2279:
	db T_interned_symbol	; *
	dq L_constants + 2260
	; L_constants + 2288:
	db T_string	; "/"
	dq 1
	db 0x2F
	; L_constants + 2298:
	db T_interned_symbol	; /
	dq L_constants + 2288
	; L_constants + 2307:
	db T_string	; "fact"
	dq 4
	db 0x66, 0x61, 0x63, 0x74
	; L_constants + 2320:
	db T_string	; "<"
	dq 1
	db 0x3C
	; L_constants + 2330:
	db T_string	; "<="
	dq 2
	db 0x3C, 0x3D
	; L_constants + 2341:
	db T_string	; ">"
	dq 1
	db 0x3E
	; L_constants + 2351:
	db T_string	; ">="
	dq 2
	db 0x3E, 0x3D
	; L_constants + 2362:
	db T_string	; "="
	dq 1
	db 0x3D
	; L_constants + 2372:
	db T_string	; "generic-comparator"
	dq 18
	db 0x67, 0x65, 0x6E, 0x65, 0x72, 0x69, 0x63, 0x2D
	db 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74
	db 0x6F, 0x72
	; L_constants + 2399:
	db T_interned_symbol	; generic-comparator
	dq L_constants + 2372
	; L_constants + 2408:
	db T_string	; "all the arguments m...
	dq 33
	db 0x61, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20
	db 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74
	db 0x73, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62
	db 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72
	db 0x73
	; L_constants + 2450:
	db T_string	; "char<?"
	dq 6
	db 0x63, 0x68, 0x61, 0x72, 0x3C, 0x3F
	; L_constants + 2465:
	db T_string	; "char<=?"
	dq 7
	db 0x63, 0x68, 0x61, 0x72, 0x3C, 0x3D, 0x3F
	; L_constants + 2481:
	db T_string	; "char=?"
	dq 6
	db 0x63, 0x68, 0x61, 0x72, 0x3D, 0x3F
	; L_constants + 2496:
	db T_string	; "char>?"
	dq 6
	db 0x63, 0x68, 0x61, 0x72, 0x3E, 0x3F
	; L_constants + 2511:
	db T_string	; "char>=?"
	dq 7
	db 0x63, 0x68, 0x61, 0x72, 0x3E, 0x3D, 0x3F
	; L_constants + 2527:
	db T_string	; "char-downcase"
	dq 13
	db 0x63, 0x68, 0x61, 0x72, 0x2D, 0x64, 0x6F, 0x77
	db 0x6E, 0x63, 0x61, 0x73, 0x65
	; L_constants + 2549:
	db T_string	; "char-upcase"
	dq 11
	db 0x63, 0x68, 0x61, 0x72, 0x2D, 0x75, 0x70, 0x63
	db 0x61, 0x73, 0x65
	; L_constants + 2569:
	db T_char, 0x41	; #\A
	; L_constants + 2571:
	db T_char, 0x5A	; #\Z
	; L_constants + 2573:
	db T_char, 0x61	; #\a
	; L_constants + 2575:
	db T_char, 0x7A	; #\z
	; L_constants + 2577:
	db T_string	; "char-ci<?"
	dq 9
	db 0x63, 0x68, 0x61, 0x72, 0x2D, 0x63, 0x69, 0x3C
	db 0x3F
	; L_constants + 2595:
	db T_string	; "char-ci<=?"
	dq 10
	db 0x63, 0x68, 0x61, 0x72, 0x2D, 0x63, 0x69, 0x3C
	db 0x3D, 0x3F
	; L_constants + 2614:
	db T_string	; "char-ci=?"
	dq 9
	db 0x63, 0x68, 0x61, 0x72, 0x2D, 0x63, 0x69, 0x3D
	db 0x3F
	; L_constants + 2632:
	db T_string	; "char-ci>?"
	dq 9
	db 0x63, 0x68, 0x61, 0x72, 0x2D, 0x63, 0x69, 0x3E
	db 0x3F
	; L_constants + 2650:
	db T_string	; "char-ci>=?"
	dq 10
	db 0x63, 0x68, 0x61, 0x72, 0x2D, 0x63, 0x69, 0x3E
	db 0x3D, 0x3F
	; L_constants + 2669:
	db T_string	; "string-downcase"
	dq 15
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x64
	db 0x6F, 0x77, 0x6E, 0x63, 0x61, 0x73, 0x65
	; L_constants + 2693:
	db T_string	; "string-upcase"
	dq 13
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x75
	db 0x70, 0x63, 0x61, 0x73, 0x65
	; L_constants + 2715:
	db T_string	; "list->string"
	dq 12
	db 0x6C, 0x69, 0x73, 0x74, 0x2D, 0x3E, 0x73, 0x74
	db 0x72, 0x69, 0x6E, 0x67
	; L_constants + 2736:
	db T_string	; "string->list"
	dq 12
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x3E
	db 0x6C, 0x69, 0x73, 0x74
	; L_constants + 2757:
	db T_string	; "string<?"
	dq 8
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3C, 0x3F
	; L_constants + 2774:
	db T_string	; "string<=?"
	dq 9
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3C, 0x3D
	db 0x3F
	; L_constants + 2792:
	db T_string	; "string=?"
	dq 8
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3D, 0x3F
	; L_constants + 2809:
	db T_string	; "string>=?"
	dq 9
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3E, 0x3D
	db 0x3F
	; L_constants + 2827:
	db T_string	; "string>?"
	dq 8
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3E, 0x3F
	; L_constants + 2844:
	db T_string	; "string-ci<?"
	dq 11
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x63
	db 0x69, 0x3C, 0x3F
	; L_constants + 2864:
	db T_string	; "string-ci<=?"
	dq 12
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x63
	db 0x69, 0x3C, 0x3D, 0x3F
	; L_constants + 2885:
	db T_string	; "string-ci=?"
	dq 11
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x63
	db 0x69, 0x3D, 0x3F
	; L_constants + 2905:
	db T_string	; "string-ci>=?"
	dq 12
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x63
	db 0x69, 0x3E, 0x3D, 0x3F
	; L_constants + 2926:
	db T_string	; "string-ci>?"
	dq 11
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x63
	db 0x69, 0x3E, 0x3F
	; L_constants + 2946:
	db T_interned_symbol	; make-vector
	dq L_constants + 1096
	; L_constants + 2955:
	db T_string	; "Usage: (make-vector...
	dq 43
	db 0x55, 0x73, 0x61, 0x67, 0x65, 0x3A, 0x20, 0x28
	db 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x76, 0x65, 0x63
	db 0x74, 0x6F, 0x72, 0x20, 0x73, 0x69, 0x7A, 0x65
	db 0x20, 0x3F, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E
	db 0x61, 0x6C, 0x2D, 0x64, 0x65, 0x66, 0x61, 0x75
	db 0x6C, 0x74, 0x29
	; L_constants + 3007:
	db T_interned_symbol	; make-string
	dq L_constants + 1116
	; L_constants + 3016:
	db T_string	; "Usage: (make-string...
	dq 43
	db 0x55, 0x73, 0x61, 0x67, 0x65, 0x3A, 0x20, 0x28
	db 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x73, 0x74, 0x72
	db 0x69, 0x6E, 0x67, 0x20, 0x73, 0x69, 0x7A, 0x65
	db 0x20, 0x3F, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E
	db 0x61, 0x6C, 0x2D, 0x64, 0x65, 0x66, 0x61, 0x75
	db 0x6C, 0x74, 0x29
	; L_constants + 3068:
	db T_string	; "list->vector"
	dq 12
	db 0x6C, 0x69, 0x73, 0x74, 0x2D, 0x3E, 0x76, 0x65
	db 0x63, 0x74, 0x6F, 0x72
	; L_constants + 3089:
	db T_string	; "vector"
	dq 6
	db 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72
	; L_constants + 3104:
	db T_string	; "vector->list"
	dq 12
	db 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x2D, 0x3E
	db 0x6C, 0x69, 0x73, 0x74
	; L_constants + 3125:
	db T_string	; "random"
	dq 6
	db 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D
	; L_constants + 3140:
	db T_string	; "positive?"
	dq 9
	db 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65
	db 0x3F
	; L_constants + 3158:
	db T_string	; "negative?"
	dq 9
	db 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65
	db 0x3F
	; L_constants + 3176:
	db T_string	; "even?"
	dq 5
	db 0x65, 0x76, 0x65, 0x6E, 0x3F
	; L_constants + 3190:
	db T_integer	; 2
	dq 2
	; L_constants + 3199:
	db T_string	; "odd?"
	dq 4
	db 0x6F, 0x64, 0x64, 0x3F
	; L_constants + 3212:
	db T_string	; "abs"
	dq 3
	db 0x61, 0x62, 0x73
	; L_constants + 3224:
	db T_string	; "equal?"
	dq 6
	db 0x65, 0x71, 0x75, 0x61, 0x6C, 0x3F
	; L_constants + 3239:
	db T_string	; "assoc"
	dq 5
	db 0x61, 0x73, 0x73, 0x6F, 0x63
	; L_constants + 3253:
	db T_string	; "string-append"
	dq 13
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x61
	db 0x70, 0x70, 0x65, 0x6E, 0x64
	; L_constants + 3275:
	db T_string	; "vector-append"
	dq 13
	db 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x2D, 0x61
	db 0x70, 0x70, 0x65, 0x6E, 0x64
	; L_constants + 3297:
	db T_string	; "string-reverse"
	dq 14
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x72
	db 0x65, 0x76, 0x65, 0x72, 0x73, 0x65
	; L_constants + 3320:
	db T_string	; "vector-reverse"
	dq 14
	db 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x2D, 0x72
	db 0x65, 0x76, 0x65, 0x72, 0x73, 0x65
	; L_constants + 3343:
	db T_string	; "string-reverse!"
	dq 15
	db 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2D, 0x72
	db 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x21
	; L_constants + 3367:
	db T_string	; "vector-reverse!"
	dq 15
	db 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x2D, 0x72
	db 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x21
	; L_constants + 3391:
	db T_string	; "make-list-thunk"
	dq 15
	db 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x6C, 0x69, 0x73
	db 0x74, 0x2D, 0x74, 0x68, 0x75, 0x6E, 0x6B
	; L_constants + 3415:
	db T_string	; "make-string-thunk"
	dq 17
	db 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x73, 0x74, 0x72
	db 0x69, 0x6E, 0x67, 0x2D, 0x74, 0x68, 0x75, 0x6E
	db 0x6B
	; L_constants + 3441:
	db T_string	; "make-vector-thunk"
	dq 17
	db 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x76, 0x65, 0x63
	db 0x74, 0x6F, 0x72, 0x2D, 0x74, 0x68, 0x75, 0x6E
	db 0x6B
	; L_constants + 3467:
	db T_string	; "logarithm"
	dq 9
	db 0x6C, 0x6F, 0x67, 0x61, 0x72, 0x69, 0x74, 0x68
	db 0x6D
	; L_constants + 3485:
	db T_real	; 1.000000
	dq 1.000000
	; L_constants + 3494:
	db T_string	; "newline"
	dq 7
	db 0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65
	; L_constants + 3510:
	db T_char, 0x0A	; #\newline
	; L_constants + 3512:
	db T_string	; "void"
	dq 4
	db 0x76, 0x6F, 0x69, 0x64
	; L_constants + 3525:
	db T_string	; "test"
	dq 4
	db 0x74, 0x65, 0x73, 0x74
	; L_constants + 3538:
	db T_string	; "a"
	dq 1
	db 0x61
	; L_constants + 3548:
	db T_interned_symbol	; a
	dq L_constants + 3538
	; L_constants + 3557:
	db T_string	; "b"
	dq 1
	db 0x62
	; L_constants + 3567:
	db T_interned_symbol	; b
	dq L_constants + 3557
	; L_constants + 3576:
	db T_string	; "c"
	dq 1
	db 0x63
	; L_constants + 3586:
	db T_interned_symbol	; c
	dq L_constants + 3576
	; L_constants + 3595:
	db T_string	; "d"
	dq 1
	db 0x64
	; L_constants + 3605:
	db T_interned_symbol	; d
	dq L_constants + 3595
	; L_constants + 3614:
	db T_string	; "e"
	dq 1
	db 0x65
	; L_constants + 3624:
	db T_interned_symbol	; e
	dq L_constants + 3614
	; L_constants + 3633:
	db T_string	; "f"
	dq 1
	db 0x66
	; L_constants + 3643:
	db T_interned_symbol	; f
	dq L_constants + 3633
	; L_constants + 3652:
	db T_string	; "g"
	dq 1
	db 0x67
	; L_constants + 3662:
	db T_interned_symbol	; g
	dq L_constants + 3652
	; L_constants + 3671:
	db T_string	; "h"
	dq 1
	db 0x68
	; L_constants + 3681:
	db T_interned_symbol	; h
	dq L_constants + 3671
	; L_constants + 3690:
	db T_string	; "i"
	dq 1
	db 0x69
	; L_constants + 3700:
	db T_interned_symbol	; i
	dq L_constants + 3690
	; L_constants + 3709:
	db T_string	; "j"
	dq 1
	db 0x6A
	; L_constants + 3719:
	db T_interned_symbol	; j
	dq L_constants + 3709
	; L_constants + 3728:
	db T_pair	; (j)
	dq L_constants + 3719, L_constants + 1
	; L_constants + 3745:
	db T_pair	; (i j)
	dq L_constants + 3700, L_constants + 3728
	; L_constants + 3762:
	db T_pair	; (h i j)
	dq L_constants + 3681, L_constants + 3745
	; L_constants + 3779:
	db T_pair	; (g h i j)
	dq L_constants + 3662, L_constants + 3762
	; L_constants + 3796:
	db T_pair	; (f g h i j)
	dq L_constants + 3643, L_constants + 3779
	; L_constants + 3813:
	db T_pair	; (e f g h i j)
	dq L_constants + 3624, L_constants + 3796
	; L_constants + 3830:
	db T_pair	; (d e f g h i j)
	dq L_constants + 3605, L_constants + 3813
	; L_constants + 3847:
	db T_pair	; (c d e f g h i j)
	dq L_constants + 3586, L_constants + 3830
	; L_constants + 3864:
	db T_pair	; (b c d e f g h i j)
	dq L_constants + 3567, L_constants + 3847
	; L_constants + 3881:
	db T_pair	; (a b c d e f g h i j...
	dq L_constants + 3548, L_constants + 3864
free_var_0:	; location of *
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2260

free_var_1:	; location of +
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2125

free_var_2:	; location of -
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2228

free_var_3:	; location of /
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2288

free_var_4:	; location of <
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2320

free_var_5:	; location of <=
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2330

free_var_6:	; location of =
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2362

free_var_7:	; location of >
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2341

free_var_8:	; location of >=
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2351

free_var_9:	; location of __bin-add-qq
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 617

free_var_10:	; location of __bin-add-rr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 533

free_var_11:	; location of __bin-add-zz
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 701

free_var_12:	; location of __bin-apply
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 513

free_var_13:	; location of __bin-div-qq
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 680

free_var_14:	; location of __bin-div-rr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 596

free_var_15:	; location of __bin-div-zz
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 764

free_var_16:	; location of __bin-equal-qq
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 903

free_var_17:	; location of __bin-equal-rr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 880

free_var_18:	; location of __bin-equal-zz
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 926

free_var_19:	; location of __bin-less-than-qq
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 826

free_var_20:	; location of __bin-less-than-rr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 799

free_var_21:	; location of __bin-less-than-zz
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 853

free_var_22:	; location of __bin-mul-qq
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 659

free_var_23:	; location of __bin-mul-rr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 575

free_var_24:	; location of __bin-mul-zz
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 743

free_var_25:	; location of __bin-sub-qq
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 638

free_var_26:	; location of __bin-sub-rr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 554

free_var_27:	; location of __bin-sub-zz
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 722

free_var_28:	; location of __bin_integer_to_fraction
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2144

free_var_29:	; location of __integer-to-fraction
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1186

free_var_30:	; location of abs
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3212

free_var_31:	; location of andmap
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2042

free_var_32:	; location of append
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2091

free_var_33:	; location of apply
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2002

free_var_34:	; location of assoc
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3239

free_var_35:	; location of caaaar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1665

free_var_36:	; location of caaadr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1680

free_var_37:	; location of caaar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1553

free_var_38:	; location of caadar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1695

free_var_39:	; location of caaddr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1710

free_var_40:	; location of caadr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1567

free_var_41:	; location of caar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1501

free_var_42:	; location of cadaar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1725

free_var_43:	; location of cadadr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1740

free_var_44:	; location of cadar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1581

free_var_45:	; location of caddar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1755

free_var_46:	; location of cadddr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1770

free_var_47:	; location of caddr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1595

free_var_48:	; location of cadr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1514

free_var_49:	; location of car
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 277

free_var_50:	; location of cdaaar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1785

free_var_51:	; location of cdaadr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1800

free_var_52:	; location of cdaar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1609

free_var_53:	; location of cdadar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1815

free_var_54:	; location of cdaddr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1830

free_var_55:	; location of cdadr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1623

free_var_56:	; location of cdar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1527

free_var_57:	; location of cddaar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1845

free_var_58:	; location of cddadr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1860

free_var_59:	; location of cddar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1637

free_var_60:	; location of cdddar
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1875

free_var_61:	; location of cddddr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1890

free_var_62:	; location of cdddr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1651

free_var_63:	; location of cddr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1540

free_var_64:	; location of cdr
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 289

free_var_65:	; location of char->integer
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 425

free_var_66:	; location of char-ci<=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2595

free_var_67:	; location of char-ci<?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2577

free_var_68:	; location of char-ci=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2614

free_var_69:	; location of char-ci>=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2650

free_var_70:	; location of char-ci>?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2632

free_var_71:	; location of char-downcase
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2527

free_var_72:	; location of char-upcase
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2549

free_var_73:	; location of char<=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2465

free_var_74:	; location of char<?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2450

free_var_75:	; location of char=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2481

free_var_76:	; location of char>=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2511

free_var_77:	; location of char>?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2496

free_var_78:	; location of char?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 48

free_var_79:	; location of cons
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 223

free_var_80:	; location of eq?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1174

free_var_81:	; location of equal?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3224

free_var_82:	; location of error
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 785

free_var_83:	; location of even?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3176

free_var_84:	; location of fact
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2307

free_var_85:	; location of fold-left
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2073

free_var_86:	; location of fold-right
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2106

free_var_87:	; location of fraction->real
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 402

free_var_88:	; location of fraction?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 152

free_var_89:	; location of integer->char
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 447

free_var_90:	; location of integer->real
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 380

free_var_91:	; location of integer?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 496

free_var_92:	; location of list
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1919

free_var_93:	; location of list*
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1962

free_var_94:	; location of list->string
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2715

free_var_95:	; location of list->vector
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3068

free_var_96:	; location of list?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1905

free_var_97:	; location of logarithm
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3467

free_var_98:	; location of make-list-thunk
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3391

free_var_99:	; location of make-string
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1116

free_var_100:	; location of make-string-thunk
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3415

free_var_101:	; location of make-vector
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1096

free_var_102:	; location of make-vector-thunk
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3441

free_var_103:	; location of map
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2030

free_var_104:	; location of negative?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3158

free_var_105:	; location of newline
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3494

free_var_106:	; location of not
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1932

free_var_107:	; location of null?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 6

free_var_108:	; location of number?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 187

free_var_109:	; location of odd?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3199

free_var_110:	; location of ormap
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2016

free_var_111:	; location of pair?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 20

free_var_112:	; location of positive?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3140

free_var_113:	; location of random
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3125

free_var_114:	; location of rational?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1944

free_var_115:	; location of real
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2238

free_var_116:	; location of real?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 138

free_var_117:	; location of remainder
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 966

free_var_118:	; location of reverse
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2057

free_var_119:	; location of string->list
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2736

free_var_120:	; location of string-append
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3253

free_var_121:	; location of string-ci<=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2864

free_var_122:	; location of string-ci<?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2844

free_var_123:	; location of string-ci=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2885

free_var_124:	; location of string-ci>=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2905

free_var_125:	; location of string-ci>?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2926

free_var_126:	; location of string-downcase
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2669

free_var_127:	; location of string-length
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 301

free_var_128:	; location of string-ref
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1018

free_var_129:	; location of string-reverse
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3297

free_var_130:	; location of string-reverse!
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3343

free_var_131:	; location of string-set!
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1076

free_var_132:	; location of string-upcase
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2693

free_var_133:	; location of string<=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2774

free_var_134:	; location of string<?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2757

free_var_135:	; location of string=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2792

free_var_136:	; location of string>=?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2809

free_var_137:	; location of string>?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 2827

free_var_138:	; location of string?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 62

free_var_139:	; location of test
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3525

free_var_140:	; location of trng
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 469

free_var_141:	; location of vector
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3089

free_var_142:	; location of vector->list
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3104

free_var_143:	; location of vector-append
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3275

free_var_144:	; location of vector-length
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 323

free_var_145:	; location of vector-ref
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1037

free_var_146:	; location of vector-reverse
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3320

free_var_147:	; location of vector-reverse!
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3367

free_var_148:	; location of vector-set!
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 1056

free_var_149:	; location of vector?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 103

free_var_150:	; location of void
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 3512

free_var_151:	; location of write-char
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 258

free_var_152:	; location of zero?
	dq .undefined_object
.undefined_object:
	db T_undefined
	dq L_constants + 482


extern printf, fprintf, stdout, stderr, fwrite, exit, putchar, getchar
global main
section .text
main:
        enter 0, 0
        push 0
        push 0
        push Lend
        enter 0, 0
	; building closure for null?
	mov rdi, free_var_107
	mov rsi, L_code_ptr_is_null
	call bind_primitive

	; building closure for pair?
	mov rdi, free_var_111
	mov rsi, L_code_ptr_is_pair
	call bind_primitive

	; building closure for char?
	mov rdi, free_var_78
	mov rsi, L_code_ptr_is_char
	call bind_primitive

	; building closure for string?
	mov rdi, free_var_138
	mov rsi, L_code_ptr_is_string
	call bind_primitive

	; building closure for vector?
	mov rdi, free_var_149
	mov rsi, L_code_ptr_is_vector
	call bind_primitive

	; building closure for real?
	mov rdi, free_var_116
	mov rsi, L_code_ptr_is_real
	call bind_primitive

	; building closure for fraction?
	mov rdi, free_var_88
	mov rsi, L_code_ptr_is_fraction
	call bind_primitive

	; building closure for number?
	mov rdi, free_var_108
	mov rsi, L_code_ptr_is_number
	call bind_primitive

	; building closure for cons
	mov rdi, free_var_79
	mov rsi, L_code_ptr_cons
	call bind_primitive

	; building closure for write-char
	mov rdi, free_var_151
	mov rsi, L_code_ptr_write_char
	call bind_primitive

	; building closure for car
	mov rdi, free_var_49
	mov rsi, L_code_ptr_car
	call bind_primitive

	; building closure for cdr
	mov rdi, free_var_64
	mov rsi, L_code_ptr_cdr
	call bind_primitive

	; building closure for string-length
	mov rdi, free_var_127
	mov rsi, L_code_ptr_string_length
	call bind_primitive

	; building closure for vector-length
	mov rdi, free_var_144
	mov rsi, L_code_ptr_vector_length
	call bind_primitive

	; building closure for integer->real
	mov rdi, free_var_90
	mov rsi, L_code_ptr_integer_to_real
	call bind_primitive

	; building closure for fraction->real
	mov rdi, free_var_87
	mov rsi, L_code_ptr_fraction_to_real
	call bind_primitive

	; building closure for char->integer
	mov rdi, free_var_65
	mov rsi, L_code_ptr_char_to_integer
	call bind_primitive

	; building closure for integer->char
	mov rdi, free_var_89
	mov rsi, L_code_ptr_integer_to_char
	call bind_primitive

	; building closure for trng
	mov rdi, free_var_140
	mov rsi, L_code_ptr_trng
	call bind_primitive

	; building closure for zero?
	mov rdi, free_var_152
	mov rsi, L_code_ptr_is_zero
	call bind_primitive

	; building closure for integer?
	mov rdi, free_var_91
	mov rsi, L_code_ptr_is_integer
	call bind_primitive

	; building closure for __bin-apply
	mov rdi, free_var_12
	mov rsi, L_code_ptr_bin_apply
	call bind_primitive

	; building closure for __bin-add-rr
	mov rdi, free_var_10
	mov rsi, L_code_ptr_raw_bin_add_rr
	call bind_primitive

	; building closure for __bin-sub-rr
	mov rdi, free_var_26
	mov rsi, L_code_ptr_raw_bin_sub_rr
	call bind_primitive

	; building closure for __bin-mul-rr
	mov rdi, free_var_23
	mov rsi, L_code_ptr_raw_bin_mul_rr
	call bind_primitive

	; building closure for __bin-div-rr
	mov rdi, free_var_14
	mov rsi, L_code_ptr_raw_bin_div_rr
	call bind_primitive

	; building closure for __bin-add-qq
	mov rdi, free_var_9
	mov rsi, L_code_ptr_raw_bin_add_qq
	call bind_primitive

	; building closure for __bin-sub-qq
	mov rdi, free_var_25
	mov rsi, L_code_ptr_raw_bin_sub_qq
	call bind_primitive

	; building closure for __bin-mul-qq
	mov rdi, free_var_22
	mov rsi, L_code_ptr_raw_bin_mul_qq
	call bind_primitive

	; building closure for __bin-div-qq
	mov rdi, free_var_13
	mov rsi, L_code_ptr_raw_bin_div_qq
	call bind_primitive

	; building closure for __bin-add-zz
	mov rdi, free_var_11
	mov rsi, L_code_ptr_raw_bin_add_zz
	call bind_primitive

	; building closure for __bin-sub-zz
	mov rdi, free_var_27
	mov rsi, L_code_ptr_raw_bin_sub_zz
	call bind_primitive

	; building closure for __bin-mul-zz
	mov rdi, free_var_24
	mov rsi, L_code_ptr_raw_bin_mul_zz
	call bind_primitive

	; building closure for __bin-div-zz
	mov rdi, free_var_15
	mov rsi, L_code_ptr_raw_bin_div_zz
	call bind_primitive

	; building closure for error
	mov rdi, free_var_82
	mov rsi, L_code_ptr_error
	call bind_primitive

	; building closure for __bin-less-than-rr
	mov rdi, free_var_20
	mov rsi, L_code_ptr_raw_less_than_rr
	call bind_primitive

	; building closure for __bin-less-than-qq
	mov rdi, free_var_19
	mov rsi, L_code_ptr_raw_less_than_qq
	call bind_primitive

	; building closure for __bin-less-than-zz
	mov rdi, free_var_21
	mov rsi, L_code_ptr_raw_less_than_zz
	call bind_primitive

	; building closure for __bin-equal-rr
	mov rdi, free_var_17
	mov rsi, L_code_ptr_raw_equal_rr
	call bind_primitive

	; building closure for __bin-equal-qq
	mov rdi, free_var_16
	mov rsi, L_code_ptr_raw_equal_qq
	call bind_primitive

	; building closure for __bin-equal-zz
	mov rdi, free_var_18
	mov rsi, L_code_ptr_raw_equal_zz
	call bind_primitive

	; building closure for remainder
	mov rdi, free_var_117
	mov rsi, L_code_ptr_remainder
	call bind_primitive

	; building closure for string-ref
	mov rdi, free_var_128
	mov rsi, L_code_ptr_string_ref
	call bind_primitive

	; building closure for vector-ref
	mov rdi, free_var_145
	mov rsi, L_code_ptr_vector_ref
	call bind_primitive

	; building closure for vector-set!
	mov rdi, free_var_148
	mov rsi, L_code_ptr_vector_set
	call bind_primitive

	; building closure for string-set!
	mov rdi, free_var_131
	mov rsi, L_code_ptr_string_set
	call bind_primitive

	; building closure for make-vector
	mov rdi, free_var_101
	mov rsi, L_code_ptr_make_vector
	call bind_primitive

	; building closure for make-string
	mov rdi, free_var_99
	mov rsi, L_code_ptr_make_string
	call bind_primitive

	; building closure for eq?
	mov rdi, free_var_80
	mov rsi, L_code_ptr_is_eq
	call bind_primitive

	; building closure for __integer-to-fraction
	mov rdi, free_var_29
	mov rsi, L_code_ptr_integer_to_fraction
	call bind_primitive

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a33:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a33
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a33
.L_lambda_simple_env_end_0a33:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a33:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a33
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a33
.L_lambda_simple_params_end_0a33:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a33
	jmp .L_lambda_simple_end_0a33
.L_lambda_simple_code_0a33:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a33
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a33:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e40:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e40
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e40
.L_tc_recycle_frame_done_0e40:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a33:	; new closure is in rax
	mov qword [free_var_41], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a34:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a34
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a34
.L_lambda_simple_env_end_0a34:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a34:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a34
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a34
.L_lambda_simple_params_end_0a34:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a34
	jmp .L_lambda_simple_end_0a34
.L_lambda_simple_code_0a34:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a34
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a34:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e41:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e41
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e41
.L_tc_recycle_frame_done_0e41:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a34:	; new closure is in rax
	mov qword [free_var_48], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a35:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a35
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a35
.L_lambda_simple_env_end_0a35:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a35:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a35
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a35
.L_lambda_simple_params_end_0a35:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a35
	jmp .L_lambda_simple_end_0a35
.L_lambda_simple_code_0a35:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a35
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a35:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e42:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e42
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e42
.L_tc_recycle_frame_done_0e42:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a35:	; new closure is in rax
	mov qword [free_var_56], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a36:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a36
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a36
.L_lambda_simple_env_end_0a36:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a36:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a36
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a36
.L_lambda_simple_params_end_0a36:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a36
	jmp .L_lambda_simple_end_0a36
.L_lambda_simple_code_0a36:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a36
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a36:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e43:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e43
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e43
.L_tc_recycle_frame_done_0e43:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a36:	; new closure is in rax
	mov qword [free_var_63], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a37:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a37
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a37
.L_lambda_simple_env_end_0a37:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a37:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a37
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a37
.L_lambda_simple_params_end_0a37:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a37
	jmp .L_lambda_simple_end_0a37
.L_lambda_simple_code_0a37:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a37
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a37:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e44:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e44
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e44
.L_tc_recycle_frame_done_0e44:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a37:	; new closure is in rax
	mov qword [free_var_37], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a38:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a38
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a38
.L_lambda_simple_env_end_0a38:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a38:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a38
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a38
.L_lambda_simple_params_end_0a38:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a38
	jmp .L_lambda_simple_end_0a38
.L_lambda_simple_code_0a38:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a38
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a38:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e45:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e45
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e45
.L_tc_recycle_frame_done_0e45:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a38:	; new closure is in rax
	mov qword [free_var_40], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a39:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a39
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a39
.L_lambda_simple_env_end_0a39:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a39:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a39
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a39
.L_lambda_simple_params_end_0a39:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a39
	jmp .L_lambda_simple_end_0a39
.L_lambda_simple_code_0a39:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a39
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a39:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e46:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e46
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e46
.L_tc_recycle_frame_done_0e46:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a39:	; new closure is in rax
	mov qword [free_var_44], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a3a:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a3a
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a3a
.L_lambda_simple_env_end_0a3a:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a3a:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a3a
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a3a
.L_lambda_simple_params_end_0a3a:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a3a
	jmp .L_lambda_simple_end_0a3a
.L_lambda_simple_code_0a3a:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a3a
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a3a:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e47:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e47
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e47
.L_tc_recycle_frame_done_0e47:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a3a:	; new closure is in rax
	mov qword [free_var_47], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a3b:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a3b
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a3b
.L_lambda_simple_env_end_0a3b:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a3b:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a3b
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a3b
.L_lambda_simple_params_end_0a3b:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a3b
	jmp .L_lambda_simple_end_0a3b
.L_lambda_simple_code_0a3b:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a3b
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a3b:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e48:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e48
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e48
.L_tc_recycle_frame_done_0e48:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a3b:	; new closure is in rax
	mov qword [free_var_52], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a3c:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a3c
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a3c
.L_lambda_simple_env_end_0a3c:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a3c:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a3c
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a3c
.L_lambda_simple_params_end_0a3c:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a3c
	jmp .L_lambda_simple_end_0a3c
.L_lambda_simple_code_0a3c:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a3c
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a3c:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e49:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e49
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e49
.L_tc_recycle_frame_done_0e49:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a3c:	; new closure is in rax
	mov qword [free_var_55], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a3d:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a3d
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a3d
.L_lambda_simple_env_end_0a3d:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a3d:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a3d
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a3d
.L_lambda_simple_params_end_0a3d:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a3d
	jmp .L_lambda_simple_end_0a3d
.L_lambda_simple_code_0a3d:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a3d
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a3d:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e4a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e4a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e4a
.L_tc_recycle_frame_done_0e4a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a3d:	; new closure is in rax
	mov qword [free_var_59], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a3e:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a3e
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a3e
.L_lambda_simple_env_end_0a3e:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a3e:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a3e
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a3e
.L_lambda_simple_params_end_0a3e:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a3e
	jmp .L_lambda_simple_end_0a3e
.L_lambda_simple_code_0a3e:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a3e
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a3e:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e4b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e4b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e4b
.L_tc_recycle_frame_done_0e4b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a3e:	; new closure is in rax
	mov qword [free_var_62], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a3f:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a3f
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a3f
.L_lambda_simple_env_end_0a3f:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a3f:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a3f
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a3f
.L_lambda_simple_params_end_0a3f:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a3f
	jmp .L_lambda_simple_end_0a3f
.L_lambda_simple_code_0a3f:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a3f
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a3f:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e4c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e4c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e4c
.L_tc_recycle_frame_done_0e4c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a3f:	; new closure is in rax
	mov qword [free_var_35], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a40:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a40
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a40
.L_lambda_simple_env_end_0a40:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a40:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a40
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a40
.L_lambda_simple_params_end_0a40:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a40
	jmp .L_lambda_simple_end_0a40
.L_lambda_simple_code_0a40:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a40
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a40:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e4d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e4d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e4d
.L_tc_recycle_frame_done_0e4d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a40:	; new closure is in rax
	mov qword [free_var_36], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a41:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a41
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a41
.L_lambda_simple_env_end_0a41:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a41:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a41
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a41
.L_lambda_simple_params_end_0a41:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a41
	jmp .L_lambda_simple_end_0a41
.L_lambda_simple_code_0a41:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a41
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a41:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e4e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e4e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e4e
.L_tc_recycle_frame_done_0e4e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a41:	; new closure is in rax
	mov qword [free_var_38], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a42:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a42
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a42
.L_lambda_simple_env_end_0a42:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a42:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a42
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a42
.L_lambda_simple_params_end_0a42:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a42
	jmp .L_lambda_simple_end_0a42
.L_lambda_simple_code_0a42:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a42
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a42:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e4f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e4f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e4f
.L_tc_recycle_frame_done_0e4f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a42:	; new closure is in rax
	mov qword [free_var_39], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a43:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a43
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a43
.L_lambda_simple_env_end_0a43:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a43:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a43
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a43
.L_lambda_simple_params_end_0a43:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a43
	jmp .L_lambda_simple_end_0a43
.L_lambda_simple_code_0a43:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a43
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a43:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e50:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e50
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e50
.L_tc_recycle_frame_done_0e50:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a43:	; new closure is in rax
	mov qword [free_var_42], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a44:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a44
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a44
.L_lambda_simple_env_end_0a44:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a44:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a44
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a44
.L_lambda_simple_params_end_0a44:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a44
	jmp .L_lambda_simple_end_0a44
.L_lambda_simple_code_0a44:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a44
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a44:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e51:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e51
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e51
.L_tc_recycle_frame_done_0e51:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a44:	; new closure is in rax
	mov qword [free_var_43], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a45:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a45
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a45
.L_lambda_simple_env_end_0a45:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a45:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a45
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a45
.L_lambda_simple_params_end_0a45:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a45
	jmp .L_lambda_simple_end_0a45
.L_lambda_simple_code_0a45:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a45
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a45:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e52:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e52
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e52
.L_tc_recycle_frame_done_0e52:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a45:	; new closure is in rax
	mov qword [free_var_45], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a46:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a46
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a46
.L_lambda_simple_env_end_0a46:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a46:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a46
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a46
.L_lambda_simple_params_end_0a46:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a46
	jmp .L_lambda_simple_end_0a46
.L_lambda_simple_code_0a46:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a46
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a46:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e53:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e53
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e53
.L_tc_recycle_frame_done_0e53:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a46:	; new closure is in rax
	mov qword [free_var_46], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a47:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a47
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a47
.L_lambda_simple_env_end_0a47:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a47:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a47
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a47
.L_lambda_simple_params_end_0a47:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a47
	jmp .L_lambda_simple_end_0a47
.L_lambda_simple_code_0a47:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a47
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a47:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e54:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e54
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e54
.L_tc_recycle_frame_done_0e54:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a47:	; new closure is in rax
	mov qword [free_var_50], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a48:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a48
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a48
.L_lambda_simple_env_end_0a48:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a48:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a48
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a48
.L_lambda_simple_params_end_0a48:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a48
	jmp .L_lambda_simple_end_0a48
.L_lambda_simple_code_0a48:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a48
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a48:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e55:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e55
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e55
.L_tc_recycle_frame_done_0e55:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a48:	; new closure is in rax
	mov qword [free_var_51], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a49:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a49
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a49
.L_lambda_simple_env_end_0a49:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a49:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a49
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a49
.L_lambda_simple_params_end_0a49:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a49
	jmp .L_lambda_simple_end_0a49
.L_lambda_simple_code_0a49:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a49
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a49:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e56:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e56
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e56
.L_tc_recycle_frame_done_0e56:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a49:	; new closure is in rax
	mov qword [free_var_53], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a4a:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a4a
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a4a
.L_lambda_simple_env_end_0a4a:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a4a:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a4a
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a4a
.L_lambda_simple_params_end_0a4a:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a4a
	jmp .L_lambda_simple_end_0a4a
.L_lambda_simple_code_0a4a:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a4a
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a4a:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e57:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e57
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e57
.L_tc_recycle_frame_done_0e57:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a4a:	; new closure is in rax
	mov qword [free_var_54], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a4b:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a4b
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a4b
.L_lambda_simple_env_end_0a4b:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a4b:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a4b
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a4b
.L_lambda_simple_params_end_0a4b:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a4b
	jmp .L_lambda_simple_end_0a4b
.L_lambda_simple_code_0a4b:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a4b
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a4b:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e58:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e58
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e58
.L_tc_recycle_frame_done_0e58:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a4b:	; new closure is in rax
	mov qword [free_var_57], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a4c:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a4c
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a4c
.L_lambda_simple_env_end_0a4c:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a4c:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a4c
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a4c
.L_lambda_simple_params_end_0a4c:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a4c
	jmp .L_lambda_simple_end_0a4c
.L_lambda_simple_code_0a4c:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a4c
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a4c:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_48]	; free var cadr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e59:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e59
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e59
.L_tc_recycle_frame_done_0e59:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a4c:	; new closure is in rax
	mov qword [free_var_58], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a4d:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a4d
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a4d
.L_lambda_simple_env_end_0a4d:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a4d:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a4d
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a4d
.L_lambda_simple_params_end_0a4d:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a4d
	jmp .L_lambda_simple_end_0a4d
.L_lambda_simple_code_0a4d:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a4d
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a4d:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_56]	; free var cdar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e5a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e5a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e5a
.L_tc_recycle_frame_done_0e5a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a4d:	; new closure is in rax
	mov qword [free_var_60], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a4e:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a4e
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a4e
.L_lambda_simple_env_end_0a4e:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a4e:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a4e
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a4e
.L_lambda_simple_params_end_0a4e:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a4e
	jmp .L_lambda_simple_end_0a4e
.L_lambda_simple_code_0a4e:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a4e
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a4e:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_63]	; free var cddr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e5b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e5b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e5b
.L_tc_recycle_frame_done_0e5b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a4e:	; new closure is in rax
	mov qword [free_var_61], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a4f:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a4f
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a4f
.L_lambda_simple_env_end_0a4f:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a4f:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a4f
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a4f
.L_lambda_simple_params_end_0a4f:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a4f
	jmp .L_lambda_simple_end_0a4f
.L_lambda_simple_code_0a4f:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a4f
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a4f:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00e0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07a9
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_96]	; free var list?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e5c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e5c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e5c
.L_tc_recycle_frame_done_0e5c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07a9
.L_if_else_07a9:
	mov rax, L_constants + 2
.L_if_end_07a9:
.L_or_end_00e0:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a4f:	; new closure is in rax
	mov qword [free_var_96], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_013f:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_opt_env_end_013f
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_013f
.L_lambda_opt_env_end_013f:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_013f:	; copy params
	cmp rsi, 0
	je .L_lambda_opt_params_end_013f
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_013f
.L_lambda_opt_params_end_013f:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_013f
	jmp .L_lambda_opt_end_013f
.L_lambda_opt_code_013f:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_opt_arity_check_exact_013f
	jg .L_lambda_opt_arity_check_more_013f
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_013f:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 1
	mov qword[rsp + 8 *2], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 0)], rax
	enter 0, 0
	mov rax, PARAM(0)	; param args
	leave
	ret AND_KILL_FRAME(1)
	jmp .L_lambda_opt_end_013f	; new closure is in rax
.L_lambda_opt_arity_check_more_013f:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_013f:
	cmp r8, 0
	je .L_lambda_opt_stack_shrink_loop_exit_013f
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_013f
.L_lambda_opt_stack_shrink_loop_exit_013f:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 1
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 0;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 1
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	mov rax, PARAM(0)	; param args
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_opt_end_013f:	; new closure is in rax
	mov qword [free_var_92], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a50:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a50
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a50
.L_lambda_simple_env_end_0a50:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a50:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a50
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a50
.L_lambda_simple_params_end_0a50:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a50
	jmp .L_lambda_simple_end_0a50
.L_lambda_simple_code_0a50:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a50
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a50:
	enter 0, 0
	mov rax, PARAM(0)	; param x
	cmp rax, sob_boolean_false
	je .L_if_else_07aa
	mov rax, L_constants + 2
	jmp .L_if_end_07aa
.L_if_else_07aa:
	mov rax, L_constants + 3
.L_if_end_07aa:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a50:	; new closure is in rax
	mov qword [free_var_106], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a51:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a51
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a51
.L_lambda_simple_env_end_0a51:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a51:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a51
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a51
.L_lambda_simple_params_end_0a51:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a51
	jmp .L_lambda_simple_end_0a51
.L_lambda_simple_code_0a51:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a51
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a51:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param q
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00e1
	; preparing a tail-call
	mov rax, PARAM(0)	; param q
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e5d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e5d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e5d
.L_tc_recycle_frame_done_0e5d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_or_end_00e1:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a51:	; new closure is in rax
	mov qword [free_var_114], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a52:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a52
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a52
.L_lambda_simple_env_end_0a52:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a52:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a52
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a52
.L_lambda_simple_params_end_0a52:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a52
	jmp .L_lambda_simple_end_0a52
.L_lambda_simple_code_0a52:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a52
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a52:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a53:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a53
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a53
.L_lambda_simple_env_end_0a53:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a53:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a53
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a53
.L_lambda_simple_params_end_0a53:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a53
	jmp .L_lambda_simple_end_0a53
.L_lambda_simple_code_0a53:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a53
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a53:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ab
	mov rax, PARAM(0)	; param a
	jmp .L_if_end_07ab
.L_if_else_07ab:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e5e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e5e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e5e
.L_tc_recycle_frame_done_0e5e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07ab:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a53:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0140:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0140
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0140
.L_lambda_opt_env_end_0140:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0140:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0140
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0140
.L_lambda_opt_params_end_0140:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0140
	jmp .L_lambda_opt_end_0140
.L_lambda_opt_code_0140:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0140
	jg .L_lambda_opt_arity_check_more_0140
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0140:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e60:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e60
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e60
.L_tc_recycle_frame_done_0e60:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0140	; new closure is in rax
.L_lambda_opt_arity_check_more_0140:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0140:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0140
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0140
.L_lambda_opt_stack_shrink_loop_exit_0140:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e5f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e5f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e5f
.L_tc_recycle_frame_done_0e5f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0140:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a52:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_93], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a54:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a54
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a54
.L_lambda_simple_env_end_0a54:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a54:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a54
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a54
.L_lambda_simple_params_end_0a54:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a54
	jmp .L_lambda_simple_end_0a54
.L_lambda_simple_code_0a54:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a54
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a54:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a55:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a55
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a55
.L_lambda_simple_env_end_0a55:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a55:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a55
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a55
.L_lambda_simple_params_end_0a55:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a55
	jmp .L_lambda_simple_end_0a55
.L_lambda_simple_code_0a55:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a55
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a55:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ac
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e61:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e61
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e61
.L_tc_recycle_frame_done_0e61:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07ac
.L_if_else_07ac:
	mov rax, PARAM(0)	; param a
.L_if_end_07ac:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a55:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0141:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0141
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0141
.L_lambda_opt_env_end_0141:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0141:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0141
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0141
.L_lambda_opt_params_end_0141:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0141
	jmp .L_lambda_opt_end_0141
.L_lambda_opt_code_0141:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0141
	jg .L_lambda_opt_arity_check_more_0141
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0141:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 2	; arg count
	mov rax, qword [free_var_12]	; free var __bin-apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e63:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e63
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e63
.L_tc_recycle_frame_done_0e63:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0141	; new closure is in rax
.L_lambda_opt_arity_check_more_0141:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0141:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0141
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0141
.L_lambda_opt_stack_shrink_loop_exit_0141:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 2	; arg count
	mov rax, qword [free_var_12]	; free var __bin-apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e62:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e62
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e62
.L_tc_recycle_frame_done_0e62:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0141:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a54:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_33], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0142:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_opt_env_end_0142
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0142
.L_lambda_opt_env_end_0142:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0142:	; copy params
	cmp rsi, 0
	je .L_lambda_opt_params_end_0142
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0142
.L_lambda_opt_params_end_0142:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0142
	jmp .L_lambda_opt_end_0142
.L_lambda_opt_code_0142:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0142
	jg .L_lambda_opt_arity_check_more_0142
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0142:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a58:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a58
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a58
.L_lambda_simple_env_end_0a58:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a58:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a58
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a58
.L_lambda_simple_params_end_0a58:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a58
	jmp .L_lambda_simple_end_0a58
.L_lambda_simple_code_0a58:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a58
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a58:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a59:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a59
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a59
.L_lambda_simple_env_end_0a59:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a59:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a59
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a59
.L_lambda_simple_params_end_0a59:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a59
	jmp .L_lambda_simple_end_0a59
.L_lambda_simple_code_0a59:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a59
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a59:
	enter 0, 0
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07af
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var f
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00e3
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var loop
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e67:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e67
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e67
.L_tc_recycle_frame_done_0e67:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_or_end_00e3:
	jmp .L_if_end_07af
.L_if_else_07af:
	mov rax, L_constants + 2
.L_if_end_07af:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a59:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param loop
	pop qword [rax]
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b0
	; preparing a tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param loop
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e68:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e68
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e68
.L_tc_recycle_frame_done_0e68:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07b0
.L_if_else_07b0:
	mov rax, L_constants + 2
.L_if_end_07b0:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a58:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e69:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e69
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e69
.L_tc_recycle_frame_done_0e69:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0142	; new closure is in rax
.L_lambda_opt_arity_check_more_0142:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0142:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0142
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0142
.L_lambda_opt_stack_shrink_loop_exit_0142:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a56:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a56
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a56
.L_lambda_simple_env_end_0a56:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a56:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a56
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a56
.L_lambda_simple_params_end_0a56:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a56
	jmp .L_lambda_simple_end_0a56
.L_lambda_simple_code_0a56:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a56
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a56:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a57:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a57
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a57
.L_lambda_simple_env_end_0a57:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a57:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a57
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a57
.L_lambda_simple_params_end_0a57:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a57
	jmp .L_lambda_simple_end_0a57
.L_lambda_simple_code_0a57:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a57
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a57:
	enter 0, 0
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ad
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var f
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00e2
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var loop
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e64:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e64
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e64
.L_tc_recycle_frame_done_0e64:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_or_end_00e2:
	jmp .L_if_end_07ad
.L_if_else_07ad:
	mov rax, L_constants + 2
.L_if_end_07ad:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a57:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param loop
	pop qword [rax]
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ae
	; preparing a tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param loop
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e65:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e65
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e65
.L_tc_recycle_frame_done_0e65:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07ae
.L_if_else_07ae:
	mov rax, L_constants + 2
.L_if_end_07ae:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a56:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e66:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e66
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e66
.L_tc_recycle_frame_done_0e66:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0142:	; new closure is in rax
	mov qword [free_var_110], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0143:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_opt_env_end_0143
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0143
.L_lambda_opt_env_end_0143:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0143:	; copy params
	cmp rsi, 0
	je .L_lambda_opt_params_end_0143
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0143
.L_lambda_opt_params_end_0143:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0143
	jmp .L_lambda_opt_end_0143
.L_lambda_opt_code_0143:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0143
	jg .L_lambda_opt_arity_check_more_0143
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0143:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a5c:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a5c
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a5c
.L_lambda_simple_env_end_0a5c:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a5c:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a5c
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a5c
.L_lambda_simple_params_end_0a5c:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a5c
	jmp .L_lambda_simple_end_0a5c
.L_lambda_simple_code_0a5c:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a5c
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a5c:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a5d:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a5d
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a5d
.L_lambda_simple_env_end_0a5d:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a5d:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a5d
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a5d
.L_lambda_simple_params_end_0a5d:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a5d
	jmp .L_lambda_simple_end_0a5d
.L_lambda_simple_code_0a5d:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a5d
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a5d:
	enter 0, 0
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00e6
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var f
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b3
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var loop
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e6d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e6d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e6d
.L_tc_recycle_frame_done_0e6d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07b3
.L_if_else_07b3:
	mov rax, L_constants + 2
.L_if_end_07b3:
.L_or_end_00e6:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a5d:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param loop
	pop qword [rax]
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00e7
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b4
	; preparing a tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param loop
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e6e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e6e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e6e
.L_tc_recycle_frame_done_0e6e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07b4
.L_if_else_07b4:
	mov rax, L_constants + 2
.L_if_end_07b4:
.L_or_end_00e7:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a5c:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e6f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e6f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e6f
.L_tc_recycle_frame_done_0e6f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0143	; new closure is in rax
.L_lambda_opt_arity_check_more_0143:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0143:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0143
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0143
.L_lambda_opt_stack_shrink_loop_exit_0143:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a5a:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a5a
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a5a
.L_lambda_simple_env_end_0a5a:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a5a:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a5a
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a5a
.L_lambda_simple_params_end_0a5a:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a5a
	jmp .L_lambda_simple_end_0a5a
.L_lambda_simple_code_0a5a:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a5a
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a5a:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a5b:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a5b
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a5b
.L_lambda_simple_env_end_0a5b:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a5b:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a5b
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a5b
.L_lambda_simple_params_end_0a5b:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a5b
	jmp .L_lambda_simple_end_0a5b
.L_lambda_simple_code_0a5b:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a5b
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a5b:
	enter 0, 0
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00e4
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var f
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b1
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var loop
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e6a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e6a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e6a
.L_tc_recycle_frame_done_0e6a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07b1
.L_if_else_07b1:
	mov rax, L_constants + 2
.L_if_end_07b1:
.L_or_end_00e4:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a5b:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param loop
	pop qword [rax]
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00e5
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b2
	; preparing a tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param loop
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e6b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e6b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e6b
.L_tc_recycle_frame_done_0e6b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07b2
.L_if_else_07b2:
	mov rax, L_constants + 2
.L_if_end_07b2:
.L_or_end_00e5:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a5a:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e6c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e6c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e6c
.L_tc_recycle_frame_done_0e6c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0143:	; new closure is in rax
	mov qword [free_var_31], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	mov rax, L_constants + 1993
	push rax
	push 2	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a5e:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a5e
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a5e
.L_lambda_simple_env_end_0a5e:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a5e:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a5e
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a5e
.L_lambda_simple_params_end_0a5e:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a5e
	jmp .L_lambda_simple_end_0a5e
.L_lambda_simple_code_0a5e:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a5e
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a5e:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(1)
	mov qword[rax], rbx
	mov PARAM(1), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a5f:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a5f
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a5f
.L_lambda_simple_env_end_0a5f:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a5f:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a5f
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a5f
.L_lambda_simple_params_end_0a5f:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a5f
	jmp .L_lambda_simple_end_0a5f
.L_lambda_simple_code_0a5f:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a5f
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a5f:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b5
	mov rax, L_constants + 1
	jmp .L_if_end_07b5
.L_if_else_07b5:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var map1
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param f
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e70:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e70
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e70
.L_tc_recycle_frame_done_0e70:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07b5:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a5f:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param map1
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a60:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a60
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a60
.L_lambda_simple_env_end_0a60:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a60:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a60
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a60
.L_lambda_simple_params_end_0a60:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a60
	jmp .L_lambda_simple_end_0a60
.L_lambda_simple_code_0a60:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a60
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a60:
	enter 0, 0
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b6
	mov rax, L_constants + 1
	jmp .L_if_end_07b6
.L_if_else_07b6:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var map1
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var map-list
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var map1
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e71:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e71
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e71
.L_tc_recycle_frame_done_0e71:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07b6:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a60:	; new closure is in rax
	push rax
	mov rax, PARAM(1)	; param map-list
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0144:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0144
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0144
.L_lambda_opt_env_end_0144:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0144:	; copy params
	cmp rsi, 2
	je .L_lambda_opt_params_end_0144
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0144
.L_lambda_opt_params_end_0144:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0144
	jmp .L_lambda_opt_end_0144
.L_lambda_opt_code_0144:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0144
	jg .L_lambda_opt_arity_check_more_0144
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0144:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b8
	mov rax, L_constants + 1
	jmp .L_if_end_07b8
.L_if_else_07b8:
	; preparing a tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var map-list
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e73:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e73
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e73
.L_tc_recycle_frame_done_0e73:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07b8:
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0144	; new closure is in rax
.L_lambda_opt_arity_check_more_0144:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0144:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0144
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0144
.L_lambda_opt_stack_shrink_loop_exit_0144:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b7
	mov rax, L_constants + 1
	jmp .L_if_end_07b7
.L_if_else_07b7:
	; preparing a tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var map-list
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e72:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e72
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e72
.L_tc_recycle_frame_done_0e72:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07b7:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0144:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a5e:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_103], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a61:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a61
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a61
.L_lambda_simple_env_end_0a61:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a61:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a61
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a61
.L_lambda_simple_params_end_0a61:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a61
	jmp .L_lambda_simple_end_0a61
.L_lambda_simple_code_0a61:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a61
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a61:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, L_constants + 1
	push rax
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a62:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a62
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a62
.L_lambda_simple_env_end_0a62:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a62:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a62
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a62
.L_lambda_simple_params_end_0a62:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a62
	jmp .L_lambda_simple_end_0a62
.L_lambda_simple_code_0a62:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a62
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a62:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param r
	push rax
	mov rax, PARAM(1)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e74:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e74
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e74
.L_tc_recycle_frame_done_0e74:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a62:	; new closure is in rax
	push rax
	push 3	; arg count
	mov rax, qword [free_var_85]	; free var fold-left
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e75:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e75
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e75
.L_tc_recycle_frame_done_0e75:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a61:	; new closure is in rax
	mov qword [free_var_118], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	mov rax, L_constants + 1993
	push rax
	push 2	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a63:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a63
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a63
.L_lambda_simple_env_end_0a63:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a63:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a63
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a63
.L_lambda_simple_params_end_0a63:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a63
	jmp .L_lambda_simple_end_0a63
.L_lambda_simple_code_0a63:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a63
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a63:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(1)
	mov qword[rax], rbx
	mov PARAM(1), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a64:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a64
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a64
.L_lambda_simple_env_end_0a64:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a64:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a64
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a64
.L_lambda_simple_params_end_0a64:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a64
	jmp .L_lambda_simple_end_0a64
.L_lambda_simple_code_0a64:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a64
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a64:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param sr
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07b9
	mov rax, PARAM(0)	; param s1
	jmp .L_if_end_07b9
.L_if_else_07b9:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param sr
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param sr
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run-1
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param s1
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var run-2
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e76:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e76
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e76
.L_tc_recycle_frame_done_0e76:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07b9:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a64:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run-1
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a65:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a65
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a65
.L_lambda_simple_env_end_0a65:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a65:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a65
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a65
.L_lambda_simple_params_end_0a65:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a65
	jmp .L_lambda_simple_end_0a65
.L_lambda_simple_code_0a65:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a65
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a65:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ba
	mov rax, PARAM(1)	; param s2
	jmp .L_if_end_07ba
.L_if_else_07ba:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s2
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var run-2
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e77:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e77
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e77
.L_tc_recycle_frame_done_0e77:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07ba:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a65:	; new closure is in rax
	push rax
	mov rax, PARAM(1)	; param run-2
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0145:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0145
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0145
.L_lambda_opt_env_end_0145:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0145:	; copy params
	cmp rsi, 2
	je .L_lambda_opt_params_end_0145
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0145
.L_lambda_opt_params_end_0145:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0145
	jmp .L_lambda_opt_end_0145
.L_lambda_opt_code_0145:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_opt_arity_check_exact_0145
	jg .L_lambda_opt_arity_check_more_0145
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0145:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 1
	mov qword[rsp + 8 *2], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 0)], rax
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07bc
	mov rax, L_constants + 1
	jmp .L_if_end_07bc
.L_if_else_07bc:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run-1
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e79:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e79
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e79
.L_tc_recycle_frame_done_0e79:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07bc:
	leave
	ret AND_KILL_FRAME(1)
	jmp .L_lambda_opt_end_0145	; new closure is in rax
.L_lambda_opt_arity_check_more_0145:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0145:
	cmp r8, 0
	je .L_lambda_opt_stack_shrink_loop_exit_0145
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0145
.L_lambda_opt_stack_shrink_loop_exit_0145:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 1
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 0;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 1
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07bb
	mov rax, L_constants + 1
	jmp .L_if_end_07bb
.L_if_else_07bb:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run-1
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e78:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e78
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e78
.L_tc_recycle_frame_done_0e78:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07bb:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_opt_end_0145:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a63:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_32], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a66:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a66
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a66
.L_lambda_simple_env_end_0a66:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a66:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a66
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a66
.L_lambda_simple_params_end_0a66:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a66
	jmp .L_lambda_simple_end_0a66
.L_lambda_simple_code_0a66:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a66
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a66:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a67:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a67
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a67
.L_lambda_simple_env_end_0a67:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a67:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a67
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a67
.L_lambda_simple_params_end_0a67:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a67
	jmp .L_lambda_simple_end_0a67
.L_lambda_simple_code_0a67:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0a67
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a67:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_110]	; free var ormap
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07bd
	mov rax, PARAM(1)	; param unit
	jmp .L_if_end_07bd
.L_if_else_07bd:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(1)	; param unit
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 3	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e7a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e7a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e7a
.L_tc_recycle_frame_done_0e7a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07bd:
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0a67:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0146:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0146
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0146
.L_lambda_opt_env_end_0146:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0146:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0146
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0146
.L_lambda_opt_params_end_0146:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0146
	jmp .L_lambda_opt_end_0146
.L_lambda_opt_code_0146:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_opt_arity_check_exact_0146
	jg .L_lambda_opt_arity_check_more_0146
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0146:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 3
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, qword[rsp + 8 * (4 + 1)]
	mov qword[rsp + 8 * (3 + 1)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 2)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, PARAM(1)	; param unit
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e7c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e7c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e7c
.L_tc_recycle_frame_done_0e7c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(3)
	jmp .L_lambda_opt_end_0146	; new closure is in rax
.L_lambda_opt_arity_check_more_0146:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0146:
	cmp r8, 2
	je .L_lambda_opt_stack_shrink_loop_exit_0146
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0146
.L_lambda_opt_stack_shrink_loop_exit_0146:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 3
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 2;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 3
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, PARAM(1)	; param unit
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e7b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e7b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e7b
.L_tc_recycle_frame_done_0e7b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_opt_end_0146:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a66:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_85], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a68:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a68
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a68
.L_lambda_simple_env_end_0a68:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a68:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a68
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a68
.L_lambda_simple_params_end_0a68:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a68
	jmp .L_lambda_simple_end_0a68
.L_lambda_simple_code_0a68:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a68
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a68:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a69:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a69
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a69
.L_lambda_simple_env_end_0a69:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a69:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a69
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a69
.L_lambda_simple_params_end_0a69:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a69
	jmp .L_lambda_simple_end_0a69
.L_lambda_simple_code_0a69:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0a69
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a69:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_110]	; free var ormap
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07be
	mov rax, PARAM(1)	; param unit
	jmp .L_if_end_07be
.L_if_else_07be:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 1
	push rax
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(1)	; param unit
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_32]	; free var append
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e7d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e7d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e7d
.L_tc_recycle_frame_done_0e7d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07be:
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0a69:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0147:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0147
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0147
.L_lambda_opt_env_end_0147:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0147:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0147
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0147
.L_lambda_opt_params_end_0147:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0147
	jmp .L_lambda_opt_end_0147
.L_lambda_opt_code_0147:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_opt_arity_check_exact_0147
	jg .L_lambda_opt_arity_check_more_0147
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0147:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 3
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, qword[rsp + 8 * (4 + 1)]
	mov qword[rsp + 8 * (3 + 1)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 2)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, PARAM(1)	; param unit
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e7f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e7f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e7f
.L_tc_recycle_frame_done_0e7f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(3)
	jmp .L_lambda_opt_end_0147	; new closure is in rax
.L_lambda_opt_arity_check_more_0147:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0147:
	cmp r8, 2
	je .L_lambda_opt_stack_shrink_loop_exit_0147
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0147
.L_lambda_opt_stack_shrink_loop_exit_0147:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 3
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 2;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 3
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(2)	; param ss
	push rax
	mov rax, PARAM(1)	; param unit
	push rax
	mov rax, PARAM(0)	; param f
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e7e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e7e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e7e
.L_tc_recycle_frame_done_0e7e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_opt_end_0147:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a68:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_86], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a6a:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a6a
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a6a
.L_lambda_simple_env_end_0a6a:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a6a:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a6a
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a6a
.L_lambda_simple_params_end_0a6a:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a6a
	jmp .L_lambda_simple_end_0a6a
.L_lambda_simple_code_0a6a:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_simple_arity_check_ok_0a6a
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a6a:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 2187
	push rax
	mov rax, L_constants + 2178
	push rax
	push 2	; arg count
	mov rax, qword [free_var_82]	; free var error
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e80:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e80
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e80
.L_tc_recycle_frame_done_0e80:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(0)
.L_lambda_simple_end_0a6a:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a6b:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a6b
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a6b
.L_lambda_simple_env_end_0a6b:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a6b:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a6b
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a6b
.L_lambda_simple_params_end_0a6b:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a6b
	jmp .L_lambda_simple_end_0a6b
.L_lambda_simple_code_0a6b:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a6b
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a6b:
	enter 0, 0
	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a6c:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a6c
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a6c
.L_lambda_simple_env_end_0a6c:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a6c:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a6c
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a6c
.L_lambda_simple_params_end_0a6c:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a6c
	jmp .L_lambda_simple_end_0a6c
.L_lambda_simple_code_0a6c:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a6c
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a6c:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ca
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c1
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_11]	; free var __bin-add-zz
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e81:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e81
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e81
.L_tc_recycle_frame_done_0e81:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07c1
.L_if_else_07c1:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c0
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_29]	; free var __integer-to-fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_9]	; free var __bin-add-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e82:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e82
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e82
.L_tc_recycle_frame_done_0e82:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07c0
.L_if_else_07c0:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07bf
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_10]	; free var __bin-add-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e83:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e83
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e83
.L_tc_recycle_frame_done_0e83:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07bf
.L_if_else_07bf:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e84:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e84
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e84
.L_tc_recycle_frame_done_0e84:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07bf:
.L_if_end_07c0:
.L_if_end_07c1:
	jmp .L_if_end_07ca
.L_if_else_07ca:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c9
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c4
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_28]	; free var __bin_integer_to_fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_9]	; free var __bin-add-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e85:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e85
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e85
.L_tc_recycle_frame_done_0e85:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07c4
.L_if_else_07c4:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c3
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_9]	; free var __bin-add-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e86:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e86
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e86
.L_tc_recycle_frame_done_0e86:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07c3
.L_if_else_07c3:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c2
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_10]	; free var __bin-add-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e87:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e87
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e87
.L_tc_recycle_frame_done_0e87:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07c2
.L_if_else_07c2:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e88:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e88
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e88
.L_tc_recycle_frame_done_0e88:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07c2:
.L_if_end_07c3:
.L_if_end_07c4:
	jmp .L_if_end_07c9
.L_if_else_07c9:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c8
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c7
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_10]	; free var __bin-add-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e89:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e89
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e89
.L_tc_recycle_frame_done_0e89:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07c7
.L_if_else_07c7:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c6
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_10]	; free var __bin-add-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e8a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e8a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e8a
.L_tc_recycle_frame_done_0e8a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07c6
.L_if_else_07c6:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07c5
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_10]	; free var __bin-add-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e8b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e8b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e8b
.L_tc_recycle_frame_done_0e8b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07c5
.L_if_else_07c5:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e8c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e8c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e8c
.L_tc_recycle_frame_done_0e8c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07c5:
.L_if_end_07c6:
.L_if_end_07c7:
	jmp .L_if_end_07c8
.L_if_else_07c8:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e8d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e8d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e8d
.L_tc_recycle_frame_done_0e8d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07c8:
.L_if_end_07c9:
.L_if_end_07ca:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a6c:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a6d:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a6d
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a6d
.L_lambda_simple_env_end_0a6d:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a6d:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a6d
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a6d
.L_lambda_simple_params_end_0a6d:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a6d
	jmp .L_lambda_simple_end_0a6d
.L_lambda_simple_code_0a6d:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a6d
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a6d:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0148:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_opt_env_end_0148
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0148
.L_lambda_opt_env_end_0148:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0148:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0148
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0148
.L_lambda_opt_params_end_0148:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0148
	jmp .L_lambda_opt_end_0148
.L_lambda_opt_code_0148:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_opt_arity_check_exact_0148
	jg .L_lambda_opt_arity_check_more_0148
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0148:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 1
	mov qword[rsp + 8 *2], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 0)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, L_constants + 2135
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin+
	push rax
	push 3	; arg count
	mov rax, qword [free_var_85]	; free var fold-left
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e8f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e8f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e8f
.L_tc_recycle_frame_done_0e8f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
	jmp .L_lambda_opt_end_0148	; new closure is in rax
.L_lambda_opt_arity_check_more_0148:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0148:
	cmp r8, 0
	je .L_lambda_opt_stack_shrink_loop_exit_0148
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0148
.L_lambda_opt_stack_shrink_loop_exit_0148:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 1
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 0;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 1
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, L_constants + 2135
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin+
	push rax
	push 3	; arg count
	mov rax, qword [free_var_85]	; free var fold-left
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e8e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e8e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e8e
.L_tc_recycle_frame_done_0e8e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_opt_end_0148:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a6d:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e90:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e90
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e90
.L_tc_recycle_frame_done_0e90:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a6b:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_1], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a6e:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a6e
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a6e
.L_lambda_simple_env_end_0a6e:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a6e:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a6e
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a6e
.L_lambda_simple_params_end_0a6e:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a6e
	jmp .L_lambda_simple_end_0a6e
.L_lambda_simple_code_0a6e:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_simple_arity_check_ok_0a6e
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a6e:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 2187
	push rax
	mov rax, L_constants + 2251
	push rax
	push 2	; arg count
	mov rax, qword [free_var_82]	; free var error
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e91:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e91
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e91
.L_tc_recycle_frame_done_0e91:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(0)
.L_lambda_simple_end_0a6e:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a6f:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a6f
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a6f
.L_lambda_simple_env_end_0a6f:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a6f:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a6f
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a6f
.L_lambda_simple_params_end_0a6f:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a6f
	jmp .L_lambda_simple_end_0a6f
.L_lambda_simple_code_0a6f:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a6f
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a6f:
	enter 0, 0
	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a70:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a70
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a70
.L_lambda_simple_env_end_0a70:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a70:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a70
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a70
.L_lambda_simple_params_end_0a70:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a70
	jmp .L_lambda_simple_end_0a70
.L_lambda_simple_code_0a70:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a70
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a70:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d6
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07cd
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_27]	; free var __bin-sub-zz
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e92:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e92
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e92
.L_tc_recycle_frame_done_0e92:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07cd
.L_if_else_07cd:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07cc
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_29]	; free var __integer-to-fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_25]	; free var __bin-sub-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e93:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e93
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e93
.L_tc_recycle_frame_done_0e93:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07cc
.L_if_else_07cc:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_115]	; free var real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07cb
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_26]	; free var __bin-sub-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e94:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e94
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e94
.L_tc_recycle_frame_done_0e94:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07cb
.L_if_else_07cb:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e95:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e95
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e95
.L_tc_recycle_frame_done_0e95:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07cb:
.L_if_end_07cc:
.L_if_end_07cd:
	jmp .L_if_end_07d6
.L_if_else_07d6:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d5
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_29]	; free var __integer-to-fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_25]	; free var __bin-sub-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e96:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e96
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e96
.L_tc_recycle_frame_done_0e96:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07d0
.L_if_else_07d0:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07cf
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_25]	; free var __bin-sub-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e97:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e97
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e97
.L_tc_recycle_frame_done_0e97:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07cf
.L_if_else_07cf:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ce
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_26]	; free var __bin-sub-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e98:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e98
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e98
.L_tc_recycle_frame_done_0e98:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07ce
.L_if_else_07ce:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e99:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e99
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e99
.L_tc_recycle_frame_done_0e99:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07ce:
.L_if_end_07cf:
.L_if_end_07d0:
	jmp .L_if_end_07d5
.L_if_else_07d5:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d4
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d3
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_26]	; free var __bin-sub-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e9a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e9a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e9a
.L_tc_recycle_frame_done_0e9a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07d3
.L_if_else_07d3:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d2
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_26]	; free var __bin-sub-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e9b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e9b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e9b
.L_tc_recycle_frame_done_0e9b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07d2
.L_if_else_07d2:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d1
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_26]	; free var __bin-sub-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e9c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e9c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e9c
.L_tc_recycle_frame_done_0e9c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07d1
.L_if_else_07d1:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e9d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e9d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e9d
.L_tc_recycle_frame_done_0e9d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07d1:
.L_if_end_07d2:
.L_if_end_07d3:
	jmp .L_if_end_07d4
.L_if_else_07d4:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e9e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e9e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e9e
.L_tc_recycle_frame_done_0e9e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07d4:
.L_if_end_07d5:
.L_if_end_07d6:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a70:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a71:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a71
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a71
.L_lambda_simple_env_end_0a71:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a71:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a71
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a71
.L_lambda_simple_params_end_0a71:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a71
	jmp .L_lambda_simple_end_0a71
.L_lambda_simple_code_0a71:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a71
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a71:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0149:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_opt_env_end_0149
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0149
.L_lambda_opt_env_end_0149:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0149:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0149
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0149
.L_lambda_opt_params_end_0149:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0149
	jmp .L_lambda_opt_end_0149
.L_lambda_opt_code_0149:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0149
	jg .L_lambda_opt_arity_check_more_0149
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0149:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d8
	; preparing a tail-call
	mov rax, PARAM(0)	; param a
	push rax
	mov rax, L_constants + 2135
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin-
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea2:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea2
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea2
.L_tc_recycle_frame_done_0ea2:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07d8
.L_if_else_07d8:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, L_constants + 2135
	push rax
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 3	; arg count
	mov rax, qword [free_var_85]	; free var fold-left
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a73:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0a73
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a73
.L_lambda_simple_env_end_0a73:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a73:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a73
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a73
.L_lambda_simple_params_end_0a73:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a73
	jmp .L_lambda_simple_end_0a73
.L_lambda_simple_code_0a73:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a73
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a73:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param b
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var bin-
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea3:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea3
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea3
.L_tc_recycle_frame_done_0ea3:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a73:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea4:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea4
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea4
.L_tc_recycle_frame_done_0ea4:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07d8:
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0149	; new closure is in rax
.L_lambda_opt_arity_check_more_0149:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0149:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0149
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0149
.L_lambda_opt_stack_shrink_loop_exit_0149:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d7
	; preparing a tail-call
	mov rax, PARAM(0)	; param a
	push rax
	mov rax, L_constants + 2135
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin-
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0e9f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0e9f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0e9f
.L_tc_recycle_frame_done_0e9f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07d7
.L_if_else_07d7:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, L_constants + 2135
	push rax
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 3	; arg count
	mov rax, qword [free_var_85]	; free var fold-left
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a72:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0a72
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a72
.L_lambda_simple_env_end_0a72:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a72:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a72
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a72
.L_lambda_simple_params_end_0a72:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a72
	jmp .L_lambda_simple_end_0a72
.L_lambda_simple_code_0a72:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a72
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a72:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param b
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var bin-
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea0:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea0
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea0
.L_tc_recycle_frame_done_0ea0:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a72:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea1:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea1
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea1
.L_tc_recycle_frame_done_0ea1:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07d7:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0149:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a71:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea5:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea5
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea5
.L_tc_recycle_frame_done_0ea5:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a6f:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_2], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a74:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a74
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a74
.L_lambda_simple_env_end_0a74:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a74:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a74
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a74
.L_lambda_simple_params_end_0a74:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a74
	jmp .L_lambda_simple_end_0a74
.L_lambda_simple_code_0a74:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_simple_arity_check_ok_0a74
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a74:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 2187
	push rax
	mov rax, L_constants + 2279
	push rax
	push 2	; arg count
	mov rax, qword [free_var_82]	; free var error
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea6:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea6
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea6
.L_tc_recycle_frame_done_0ea6:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(0)
.L_lambda_simple_end_0a74:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a75:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a75
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a75
.L_lambda_simple_env_end_0a75:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a75:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a75
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a75
.L_lambda_simple_params_end_0a75:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a75
	jmp .L_lambda_simple_end_0a75
.L_lambda_simple_code_0a75:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a75
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a75:
	enter 0, 0
	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a76:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a76
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a76
.L_lambda_simple_env_end_0a76:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a76:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a76
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a76
.L_lambda_simple_params_end_0a76:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a76
	jmp .L_lambda_simple_end_0a76
.L_lambda_simple_code_0a76:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a76
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a76:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e4
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07db
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_24]	; free var __bin-mul-zz
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea7:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea7
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea7
.L_tc_recycle_frame_done_0ea7:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07db
.L_if_else_07db:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07da
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_29]	; free var __integer-to-fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_22]	; free var __bin-mul-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea8:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea8
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea8
.L_tc_recycle_frame_done_0ea8:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07da
.L_if_else_07da:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07d9
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_23]	; free var __bin-mul-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ea9:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ea9
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ea9
.L_tc_recycle_frame_done_0ea9:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07d9
.L_if_else_07d9:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eaa:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eaa
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eaa
.L_tc_recycle_frame_done_0eaa:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07d9:
.L_if_end_07da:
.L_if_end_07db:
	jmp .L_if_end_07e4
.L_if_else_07e4:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e3
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07de
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_29]	; free var __integer-to-fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_22]	; free var __bin-mul-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eab:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eab
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eab
.L_tc_recycle_frame_done_0eab:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07de
.L_if_else_07de:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07dd
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_22]	; free var __bin-mul-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eac:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eac
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eac
.L_tc_recycle_frame_done_0eac:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07dd
.L_if_else_07dd:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07dc
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_23]	; free var __bin-mul-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ead:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ead
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ead
.L_tc_recycle_frame_done_0ead:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07dc
.L_if_else_07dc:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eae:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eae
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eae
.L_tc_recycle_frame_done_0eae:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07dc:
.L_if_end_07dd:
.L_if_end_07de:
	jmp .L_if_end_07e3
.L_if_else_07e3:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e2
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e1
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_23]	; free var __bin-mul-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eaf:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eaf
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eaf
.L_tc_recycle_frame_done_0eaf:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07e1
.L_if_else_07e1:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_23]	; free var __bin-mul-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb0:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb0
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb0
.L_tc_recycle_frame_done_0eb0:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07e0
.L_if_else_07e0:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07df
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_23]	; free var __bin-mul-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb1:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb1
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb1
.L_tc_recycle_frame_done_0eb1:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07df
.L_if_else_07df:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb2:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb2
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb2
.L_tc_recycle_frame_done_0eb2:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07df:
.L_if_end_07e0:
.L_if_end_07e1:
	jmp .L_if_end_07e2
.L_if_else_07e2:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb3:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb3
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb3
.L_tc_recycle_frame_done_0eb3:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07e2:
.L_if_end_07e3:
.L_if_end_07e4:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a76:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a77:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a77
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a77
.L_lambda_simple_env_end_0a77:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a77:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a77
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a77
.L_lambda_simple_params_end_0a77:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a77
	jmp .L_lambda_simple_end_0a77
.L_lambda_simple_code_0a77:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a77
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a77:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_014a:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_opt_env_end_014a
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_014a
.L_lambda_opt_env_end_014a:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_014a:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_014a
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_014a
.L_lambda_opt_params_end_014a:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_014a
	jmp .L_lambda_opt_end_014a
.L_lambda_opt_code_014a:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_opt_arity_check_exact_014a
	jg .L_lambda_opt_arity_check_more_014a
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_014a:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 1
	mov qword[rsp + 8 *2], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 0)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, L_constants + 2270
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin*
	push rax
	push 3	; arg count
	mov rax, qword [free_var_85]	; free var fold-left
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb5:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb5
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb5
.L_tc_recycle_frame_done_0eb5:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
	jmp .L_lambda_opt_end_014a	; new closure is in rax
.L_lambda_opt_arity_check_more_014a:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_014a:
	cmp r8, 0
	je .L_lambda_opt_stack_shrink_loop_exit_014a
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_014a
.L_lambda_opt_stack_shrink_loop_exit_014a:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 1
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 0;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 1
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, L_constants + 2270
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin*
	push rax
	push 3	; arg count
	mov rax, qword [free_var_85]	; free var fold-left
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb4:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb4
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb4
.L_tc_recycle_frame_done_0eb4:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_opt_end_014a:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a77:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb6:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb6
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb6
.L_tc_recycle_frame_done_0eb6:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a75:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_0], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a78:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a78
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a78
.L_lambda_simple_env_end_0a78:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a78:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a78
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a78
.L_lambda_simple_params_end_0a78:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a78
	jmp .L_lambda_simple_end_0a78
.L_lambda_simple_code_0a78:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_simple_arity_check_ok_0a78
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a78:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 2187
	push rax
	mov rax, L_constants + 2298
	push rax
	push 2	; arg count
	mov rax, qword [free_var_82]	; free var error
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb7:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb7
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb7
.L_tc_recycle_frame_done_0eb7:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(0)
.L_lambda_simple_end_0a78:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a79:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a79
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a79
.L_lambda_simple_env_end_0a79:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a79:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a79
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a79
.L_lambda_simple_params_end_0a79:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a79
	jmp .L_lambda_simple_end_0a79
.L_lambda_simple_code_0a79:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a79
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a79:
	enter 0, 0
	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a7a:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a7a
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a7a
.L_lambda_simple_env_end_0a7a:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a7a:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a7a
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a7a
.L_lambda_simple_params_end_0a7a:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a7a
	jmp .L_lambda_simple_end_0a7a
.L_lambda_simple_code_0a7a:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a7a
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a7a:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e7
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_15]	; free var __bin-div-zz
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb8:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb8
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb8
.L_tc_recycle_frame_done_0eb8:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07e7
.L_if_else_07e7:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e6
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_29]	; free var __integer-to-fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_13]	; free var __bin-div-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eb9:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eb9
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eb9
.L_tc_recycle_frame_done_0eb9:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07e6
.L_if_else_07e6:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e5
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_14]	; free var __bin-div-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eba:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eba
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eba
.L_tc_recycle_frame_done_0eba:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07e5
.L_if_else_07e5:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ebb:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ebb
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ebb
.L_tc_recycle_frame_done_0ebb:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07e5:
.L_if_end_07e6:
.L_if_end_07e7:
	jmp .L_if_end_07f0
.L_if_else_07f0:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ef
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ea
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_29]	; free var __integer-to-fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_13]	; free var __bin-div-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ebc:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ebc
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ebc
.L_tc_recycle_frame_done_0ebc:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07ea
.L_if_else_07ea:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e9
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_13]	; free var __bin-div-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ebd:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ebd
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ebd
.L_tc_recycle_frame_done_0ebd:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07e9
.L_if_else_07e9:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07e8
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_14]	; free var __bin-div-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ebe:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ebe
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ebe
.L_tc_recycle_frame_done_0ebe:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07e8
.L_if_else_07e8:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ebf:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ebf
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ebf
.L_tc_recycle_frame_done_0ebf:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07e8:
.L_if_end_07e9:
.L_if_end_07ea:
	jmp .L_if_end_07ef
.L_if_else_07ef:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ee
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ed
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_14]	; free var __bin-div-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec0:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec0
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec0
.L_tc_recycle_frame_done_0ec0:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07ed
.L_if_else_07ed:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ec
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_14]	; free var __bin-div-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec1:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec1
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec1
.L_tc_recycle_frame_done_0ec1:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07ec
.L_if_else_07ec:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07eb
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_14]	; free var __bin-div-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec2:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec2
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec2
.L_tc_recycle_frame_done_0ec2:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07eb
.L_if_else_07eb:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec3:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec3
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec3
.L_tc_recycle_frame_done_0ec3:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07eb:
.L_if_end_07ec:
.L_if_end_07ed:
	jmp .L_if_end_07ee
.L_if_else_07ee:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var error
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec4:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec4
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec4
.L_tc_recycle_frame_done_0ec4:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07ee:
.L_if_end_07ef:
.L_if_end_07f0:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a7a:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a7b:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a7b
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a7b
.L_lambda_simple_env_end_0a7b:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a7b:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a7b
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a7b
.L_lambda_simple_params_end_0a7b:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a7b
	jmp .L_lambda_simple_end_0a7b
.L_lambda_simple_code_0a7b:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a7b
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a7b:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_014b:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_opt_env_end_014b
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_014b
.L_lambda_opt_env_end_014b:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_014b:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_014b
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_014b
.L_lambda_opt_params_end_014b:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_014b
	jmp .L_lambda_opt_end_014b
.L_lambda_opt_code_014b:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_014b
	jg .L_lambda_opt_arity_check_more_014b
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_014b:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f2
	; preparing a tail-call
	mov rax, PARAM(0)	; param a
	push rax
	mov rax, L_constants + 2270
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin/
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec8:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec8
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec8
.L_tc_recycle_frame_done_0ec8:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07f2
.L_if_else_07f2:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, L_constants + 2270
	push rax
	mov rax, qword [free_var_0]	; free var *
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 3	; arg count
	mov rax, qword [free_var_85]	; free var fold-left
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a7d:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0a7d
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a7d
.L_lambda_simple_env_end_0a7d:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a7d:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a7d
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a7d
.L_lambda_simple_params_end_0a7d:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a7d
	jmp .L_lambda_simple_end_0a7d
.L_lambda_simple_code_0a7d:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a7d
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a7d:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param b
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var bin/
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec9:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec9
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec9
.L_tc_recycle_frame_done_0ec9:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a7d:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eca:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eca
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eca
.L_tc_recycle_frame_done_0eca:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07f2:
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_014b	; new closure is in rax
.L_lambda_opt_arity_check_more_014b:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_014b:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_014b
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_014b
.L_lambda_opt_stack_shrink_loop_exit_014b:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f1
	; preparing a tail-call
	mov rax, PARAM(0)	; param a
	push rax
	mov rax, L_constants + 2270
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin/
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec5:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec5
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec5
.L_tc_recycle_frame_done_0ec5:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07f1
.L_if_else_07f1:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, L_constants + 2270
	push rax
	mov rax, qword [free_var_0]	; free var *
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 3	; arg count
	mov rax, qword [free_var_85]	; free var fold-left
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a7c:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0a7c
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a7c
.L_lambda_simple_env_end_0a7c:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a7c:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a7c
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a7c
.L_lambda_simple_params_end_0a7c:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a7c
	jmp .L_lambda_simple_end_0a7c
.L_lambda_simple_code_0a7c:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a7c
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a7c:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param b
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var bin/
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec6:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec6
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec6
.L_tc_recycle_frame_done_0ec6:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a7c:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ec7:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ec7
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ec7
.L_tc_recycle_frame_done_0ec7:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07f1:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_014b:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a7b:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ecb:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ecb
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ecb
.L_tc_recycle_frame_done_0ecb:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a79:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_3], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a7e:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a7e
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a7e
.L_lambda_simple_env_end_0a7e:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a7e:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a7e
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a7e
.L_lambda_simple_params_end_0a7e:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a7e
	jmp .L_lambda_simple_end_0a7e
.L_lambda_simple_code_0a7e:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a7e
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a7e:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param n
	push rax
	push 1	; arg count
	mov rax, qword [free_var_152]	; free var zero?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f3
	mov rax, L_constants + 2270
	jmp .L_if_end_07f3
.L_if_else_07f3:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(0)	; param n
	push rax
	push 2	; arg count
	mov rax, qword [free_var_2]	; free var -
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_84]	; free var fact
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param n
	push rax
	push 2	; arg count
	mov rax, qword [free_var_0]	; free var *
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ecc:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ecc
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ecc
.L_tc_recycle_frame_done_0ecc:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07f3:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a7e:	; new closure is in rax
	mov qword [free_var_84], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_4], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_5], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_7], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_8], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_6], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a7f:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a7f
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a7f
.L_lambda_simple_env_end_0a7f:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a7f:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a7f
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a7f
.L_lambda_simple_params_end_0a7f:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a7f
	jmp .L_lambda_simple_end_0a7f
.L_lambda_simple_code_0a7f:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_simple_arity_check_ok_0a7f
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a7f:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 2408
	push rax
	mov rax, L_constants + 2399
	push rax
	push 2	; arg count
	mov rax, qword [free_var_82]	; free var error
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ecd:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ecd
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ecd
.L_tc_recycle_frame_done_0ecd:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(0)
.L_lambda_simple_end_0a7f:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a80:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a80
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a80
.L_lambda_simple_env_end_0a80:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a80:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a80
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a80
.L_lambda_simple_params_end_0a80:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a80
	jmp .L_lambda_simple_end_0a80
.L_lambda_simple_code_0a80:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a80
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a80:
	enter 0, 0
	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a81:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a81
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a81
.L_lambda_simple_env_end_0a81:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a81:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a81
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a81
.L_lambda_simple_params_end_0a81:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a81
	jmp .L_lambda_simple_end_0a81
.L_lambda_simple_code_0a81:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0a81
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a81:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 3	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a82:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a82
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a82
.L_lambda_simple_env_end_0a82:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a82:	; copy params
	cmp rsi, 3
	je .L_lambda_simple_params_end_0a82
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a82
.L_lambda_simple_params_end_0a82:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a82
	jmp .L_lambda_simple_end_0a82
.L_lambda_simple_code_0a82:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a82
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a82:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07ff
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f6
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var comparator-zz
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ece:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ece
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ece
.L_tc_recycle_frame_done_0ece:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07f6
.L_if_else_07f6:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f5
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_29]	; free var __integer-to-fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var comparator-qq
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ecf:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ecf
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ecf
.L_tc_recycle_frame_done_0ecf:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07f5
.L_if_else_07f5:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f4
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var comparator-rr
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed0:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed0
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed0
.L_tc_recycle_frame_done_0ed0:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07f4
.L_if_else_07f4:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var exit
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed1:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed1
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed1
.L_tc_recycle_frame_done_0ed1:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07f4:
.L_if_end_07f5:
.L_if_end_07f6:
	jmp .L_if_end_07ff
.L_if_else_07ff:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07fe
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f9
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_29]	; free var __integer-to-fraction
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var comparator-qq
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed2:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed2
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed2
.L_tc_recycle_frame_done_0ed2:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07f9
.L_if_else_07f9:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f8
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var comparator-qq
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed3:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed3
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed3
.L_tc_recycle_frame_done_0ed3:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07f8
.L_if_else_07f8:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07f7
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var comparator-rr
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed4:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed4
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed4
.L_tc_recycle_frame_done_0ed4:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07f7
.L_if_else_07f7:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var exit
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed5:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed5
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed5
.L_tc_recycle_frame_done_0ed5:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07f7:
.L_if_end_07f8:
.L_if_end_07f9:
	jmp .L_if_end_07fe
.L_if_else_07fe:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07fd
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_91]	; free var integer?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07fc
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_90]	; free var integer->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var comparator-rr
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed6:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed6
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed6
.L_tc_recycle_frame_done_0ed6:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07fc
.L_if_else_07fc:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_88]	; free var fraction?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07fb
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_87]	; free var fraction->real
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var comparator-rr
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed7:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed7
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed7
.L_tc_recycle_frame_done_0ed7:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07fb
.L_if_else_07fb:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	push 1	; arg count
	mov rax, qword [free_var_116]	; free var real?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_07fa
	; preparing a tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var comparator-rr
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed8:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed8
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed8
.L_tc_recycle_frame_done_0ed8:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_07fa
.L_if_else_07fa:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var exit
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ed9:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ed9
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ed9
.L_tc_recycle_frame_done_0ed9:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07fa:
.L_if_end_07fb:
.L_if_end_07fc:
	jmp .L_if_end_07fd
.L_if_else_07fd:
	; preparing a tail-call
	push 0	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var exit
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eda:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eda
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eda
.L_tc_recycle_frame_done_0eda:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_07fd:
.L_if_end_07fe:
.L_if_end_07ff:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a82:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0a81:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a83:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a83
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a83
.L_lambda_simple_env_end_0a83:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a83:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a83
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a83
.L_lambda_simple_params_end_0a83:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a83
	jmp .L_lambda_simple_end_0a83
.L_lambda_simple_code_0a83:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a83
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a83:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, qword [free_var_20]	; free var __bin-less-than-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_19]	; free var __bin-less-than-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_21]	; free var __bin-less-than-zz
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 3	; arg count
	mov rax, PARAM(0)	; param make-bin-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a84:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a84
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a84
.L_lambda_simple_env_end_0a84:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a84:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a84
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a84
.L_lambda_simple_params_end_0a84:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a84
	jmp .L_lambda_simple_end_0a84
.L_lambda_simple_code_0a84:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a84
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a84:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, qword [free_var_17]	; free var __bin-equal-rr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_16]	; free var __bin-equal-qq
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_18]	; free var __bin-equal-zz
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var make-bin-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a85:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0a85
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a85
.L_lambda_simple_env_end_0a85:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a85:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a85
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a85
.L_lambda_simple_params_end_0a85:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a85
	jmp .L_lambda_simple_end_0a85
.L_lambda_simple_code_0a85:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a85
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a85:
	enter 0, 0
	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 5	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a86:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 4
	je .L_lambda_simple_env_end_0a86
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a86
.L_lambda_simple_env_end_0a86:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a86:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a86
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a86
.L_lambda_simple_params_end_0a86:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a86
	jmp .L_lambda_simple_end_0a86
.L_lambda_simple_code_0a86:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a86
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a86:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var bin<?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_106]	; free var not
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0edb:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0edb
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0edb
.L_tc_recycle_frame_done_0edb:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a86:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 5	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a87:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 4
	je .L_lambda_simple_env_end_0a87
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a87
.L_lambda_simple_env_end_0a87:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a87:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a87
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a87
.L_lambda_simple_params_end_0a87:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a87
	jmp .L_lambda_simple_end_0a87
.L_lambda_simple_code_0a87:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a87
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a87:
	enter 0, 0
	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 6	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a88:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 5
	je .L_lambda_simple_env_end_0a88
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a88
.L_lambda_simple_env_end_0a88:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a88:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a88
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a88
.L_lambda_simple_params_end_0a88:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a88
	jmp .L_lambda_simple_end_0a88
.L_lambda_simple_code_0a88:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a88
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a88:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param a
	push rax
	mov rax, PARAM(1)	; param b
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 2]
	mov rax, qword [rax + 8 * 0]	; bound var bin<?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0edc:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0edc
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0edc
.L_tc_recycle_frame_done_0edc:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a88:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 6	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a89:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 5
	je .L_lambda_simple_env_end_0a89
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a89
.L_lambda_simple_env_end_0a89:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a89:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a89
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a89
.L_lambda_simple_params_end_0a89:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a89
	jmp .L_lambda_simple_end_0a89
.L_lambda_simple_code_0a89:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a89
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a89:
	enter 0, 0
	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 7	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a8a:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 6
	je .L_lambda_simple_env_end_0a8a
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a8a
.L_lambda_simple_env_end_0a8a:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a8a:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a8a
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a8a
.L_lambda_simple_params_end_0a8a:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a8a
	jmp .L_lambda_simple_end_0a8a
.L_lambda_simple_code_0a8a:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a8a
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a8a:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin>?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_106]	; free var not
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0edd:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0edd
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0edd
.L_tc_recycle_frame_done_0edd:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a8a:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 7	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a8b:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 6
	je .L_lambda_simple_env_end_0a8b
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a8b
.L_lambda_simple_env_end_0a8b:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a8b:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a8b
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a8b
.L_lambda_simple_params_end_0a8b:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a8b
	jmp .L_lambda_simple_end_0a8b
.L_lambda_simple_code_0a8b:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a8b
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a8b:
	enter 0, 0
	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 8	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a8c:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 7
	je .L_lambda_simple_env_end_0a8c
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a8c
.L_lambda_simple_env_end_0a8c:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a8c:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a8c
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a8c
.L_lambda_simple_params_end_0a8c:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a8c
	jmp .L_lambda_simple_end_0a8c
.L_lambda_simple_code_0a8c:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a8c
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a8c:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 9	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a8d:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 8
	je .L_lambda_simple_env_end_0a8d
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a8d
.L_lambda_simple_env_end_0a8d:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a8d:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a8d
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a8d
.L_lambda_simple_params_end_0a8d:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a8d
	jmp .L_lambda_simple_end_0a8d
.L_lambda_simple_code_0a8d:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a8d
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a8d:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 10	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a8e:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 9
	je .L_lambda_simple_env_end_0a8e
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a8e
.L_lambda_simple_env_end_0a8e:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a8e:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a8e
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a8e
.L_lambda_simple_params_end_0a8e:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a8e
	jmp .L_lambda_simple_end_0a8e
.L_lambda_simple_code_0a8e:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a8e
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a8e:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00e8
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var bin-ordering
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0800
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ede:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ede
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ede
.L_tc_recycle_frame_done_0ede:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0800
.L_if_else_0800:
	mov rax, L_constants + 2
.L_if_end_0800:
.L_or_end_00e8:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a8e:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 10	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_014c:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 9
	je .L_lambda_opt_env_end_014c
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_014c
.L_lambda_opt_env_end_014c:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_014c:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_014c
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_014c
.L_lambda_opt_params_end_014c:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_014c
	jmp .L_lambda_opt_end_014c
.L_lambda_opt_code_014c:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_014c
	jg .L_lambda_opt_arity_check_more_014c
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_014c:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee0:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee0
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee0
.L_tc_recycle_frame_done_0ee0:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_014c	; new closure is in rax
.L_lambda_opt_arity_check_more_014c:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_014c:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_014c
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_014c
.L_lambda_opt_stack_shrink_loop_exit_014c:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param s
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0edf:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0edf
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0edf
.L_tc_recycle_frame_done_0edf:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_014c:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a8d:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee1:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee1
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee1
.L_tc_recycle_frame_done_0ee1:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a8c:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 8	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a8f:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 7
	je .L_lambda_simple_env_end_0a8f
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a8f
.L_lambda_simple_env_end_0a8f:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a8f:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a8f
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a8f
.L_lambda_simple_params_end_0a8f:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a8f
	jmp .L_lambda_simple_end_0a8f
.L_lambda_simple_code_0a8f:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a8f
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a8f:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 4]
	mov rax, qword [rax + 8 * 0]	; bound var bin<?
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-run
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_4], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var bin<=?
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-run
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_5], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var bin>?
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-run
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_7], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 2]
	mov rax, qword [rax + 8 * 0]	; bound var bin>=?
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-run
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_8], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 3]
	mov rax, qword [rax + 8 * 0]	; bound var bin=?
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-run
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_6], rax
	mov rax, sob_void
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a8f:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee2:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee2
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee2
.L_tc_recycle_frame_done_0ee2:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a8b:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee3:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee3
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee3
.L_tc_recycle_frame_done_0ee3:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a89:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee4:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee4
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee4
.L_tc_recycle_frame_done_0ee4:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a87:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee5:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee5
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee5
.L_tc_recycle_frame_done_0ee5:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a85:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee6:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee6
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee6
.L_tc_recycle_frame_done_0ee6:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a84:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee7:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee7
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee7
.L_tc_recycle_frame_done_0ee7:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a83:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee8:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee8
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee8
.L_tc_recycle_frame_done_0ee8:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a80:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_74], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_73], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_75], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_77], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_76], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a90:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a90
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a90
.L_lambda_simple_env_end_0a90:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a90:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a90
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a90
.L_lambda_simple_params_end_0a90:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a90
	jmp .L_lambda_simple_end_0a90
.L_lambda_simple_code_0a90:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a90
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a90:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_014d:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_014d
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_014d
.L_lambda_opt_env_end_014d:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_014d:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_014d
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_014d
.L_lambda_opt_params_end_014d:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_014d
	jmp .L_lambda_opt_end_014d
.L_lambda_opt_code_014d:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_opt_arity_check_exact_014d
	jg .L_lambda_opt_arity_check_more_014d
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_014d:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 1
	mov qword[rsp + 8 *2], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 0)], rax
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_65]	; free var char->integer
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var comparator
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eea:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eea
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eea
.L_tc_recycle_frame_done_0eea:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
	jmp .L_lambda_opt_end_014d	; new closure is in rax
.L_lambda_opt_arity_check_more_014d:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_014d:
	cmp r8, 0
	je .L_lambda_opt_stack_shrink_loop_exit_014d
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_014d
.L_lambda_opt_stack_shrink_loop_exit_014d:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 1
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 0;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 1
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rax, qword [free_var_65]	; free var char->integer
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var comparator
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ee9:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ee9
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ee9
.L_tc_recycle_frame_done_0ee9:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_opt_end_014d:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a90:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a91:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a91
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a91
.L_lambda_simple_env_end_0a91:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a91:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a91
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a91
.L_lambda_simple_params_end_0a91:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a91
	jmp .L_lambda_simple_end_0a91
.L_lambda_simple_code_0a91:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a91
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a91:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_74], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_5]	; free var <=
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_73], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_75], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_7]	; free var >
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_77], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_8]	; free var >=
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_76], rax
	mov rax, sob_void
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a91:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_71], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_72], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2569
	push rax
	push 1	; arg count
	mov rax, qword [free_var_65]	; free var char->integer
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2573
	push rax
	push 1	; arg count
	mov rax, qword [free_var_65]	; free var char->integer
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_2]	; free var -
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a92:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a92
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a92
.L_lambda_simple_env_end_0a92:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a92:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a92
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a92
.L_lambda_simple_params_end_0a92:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a92
	jmp .L_lambda_simple_end_0a92
.L_lambda_simple_code_0a92:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a92
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a92:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a93:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a93
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a93
.L_lambda_simple_env_end_0a93:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a93:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a93
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a93
.L_lambda_simple_params_end_0a93:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a93
	jmp .L_lambda_simple_end_0a93
.L_lambda_simple_code_0a93:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a93
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a93:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, L_constants + 2571
	push rax
	mov rax, PARAM(0)	; param ch
	push rax
	mov rax, L_constants + 2569
	push rax
	push 3	; arg count
	mov rax, qword [free_var_73]	; free var char<=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0801
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var delta
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param ch
	push rax
	push 1	; arg count
	mov rax, qword [free_var_65]	; free var char->integer
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_89]	; free var integer->char
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eeb:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eeb
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eeb
.L_tc_recycle_frame_done_0eeb:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0801
.L_if_else_0801:
	mov rax, PARAM(0)	; param ch
.L_if_end_0801:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a93:	; new closure is in rax
	mov qword [free_var_71], rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a94:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a94
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a94
.L_lambda_simple_env_end_0a94:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a94:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a94
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a94
.L_lambda_simple_params_end_0a94:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a94
	jmp .L_lambda_simple_end_0a94
.L_lambda_simple_code_0a94:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a94
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a94:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, L_constants + 2575
	push rax
	mov rax, PARAM(0)	; param ch
	push rax
	mov rax, L_constants + 2573
	push rax
	push 3	; arg count
	mov rax, qword [free_var_73]	; free var char<=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0802
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var delta
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param ch
	push rax
	push 1	; arg count
	mov rax, qword [free_var_65]	; free var char->integer
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_2]	; free var -
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_89]	; free var integer->char
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eec:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eec
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eec
.L_tc_recycle_frame_done_0eec:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0802
.L_if_else_0802:
	mov rax, PARAM(0)	; param ch
.L_if_end_0802:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a94:	; new closure is in rax
	mov qword [free_var_72], rax
	mov rax, sob_void
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a92:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_67], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_66], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_68], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_70], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_69], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a95:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a95
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a95
.L_lambda_simple_env_end_0a95:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a95:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a95
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a95
.L_lambda_simple_params_end_0a95:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a95
	jmp .L_lambda_simple_end_0a95
.L_lambda_simple_code_0a95:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a95
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a95:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_014e:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_014e
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_014e
.L_lambda_opt_env_end_014e:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_014e:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_014e
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_014e
.L_lambda_opt_params_end_014e:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_014e
	jmp .L_lambda_opt_end_014e
.L_lambda_opt_code_014e:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_opt_arity_check_exact_014e
	jg .L_lambda_opt_arity_check_more_014e
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_014e:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 1
	mov qword[rsp + 8 *2], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 0)], rax
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a97:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a97
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a97
.L_lambda_simple_env_end_0a97:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a97:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a97
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a97
.L_lambda_simple_params_end_0a97:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a97
	jmp .L_lambda_simple_end_0a97
.L_lambda_simple_code_0a97:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a97
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a97:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param ch
	push rax
	push 1	; arg count
	mov rax, qword [free_var_71]	; free var char-downcase
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_65]	; free var char->integer
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eef:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eef
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eef
.L_tc_recycle_frame_done_0eef:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a97:	; new closure is in rax
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var comparator
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef0:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef0
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef0
.L_tc_recycle_frame_done_0ef0:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
	jmp .L_lambda_opt_end_014e	; new closure is in rax
.L_lambda_opt_arity_check_more_014e:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_014e:
	cmp r8, 0
	je .L_lambda_opt_stack_shrink_loop_exit_014e
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_014e
.L_lambda_opt_stack_shrink_loop_exit_014e:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 1
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 0;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 1
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a96:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a96
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a96
.L_lambda_simple_env_end_0a96:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a96:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a96
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a96
.L_lambda_simple_params_end_0a96:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a96
	jmp .L_lambda_simple_end_0a96
.L_lambda_simple_code_0a96:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a96
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a96:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param ch
	push rax
	push 1	; arg count
	mov rax, qword [free_var_71]	; free var char-downcase
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_65]	; free var char->integer
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eed:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eed
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eed
.L_tc_recycle_frame_done_0eed:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a96:	; new closure is in rax
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var comparator
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eee:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eee
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eee
.L_tc_recycle_frame_done_0eee:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_opt_end_014e:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a95:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a98:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a98
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a98
.L_lambda_simple_env_end_0a98:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a98:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a98
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a98
.L_lambda_simple_params_end_0a98:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a98
	jmp .L_lambda_simple_end_0a98
.L_lambda_simple_code_0a98:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a98
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a98:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-ci-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_67], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_5]	; free var <=
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-ci-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_66], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-ci-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_68], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_7]	; free var >
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-ci-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_70], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_8]	; free var >=
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-char-ci-comparator
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_69], rax
	mov rax, sob_void
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a98:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_126], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_132], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a99:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a99
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a99
.L_lambda_simple_env_end_0a99:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a99:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a99
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a99
.L_lambda_simple_params_end_0a99:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a99
	jmp .L_lambda_simple_end_0a99
.L_lambda_simple_code_0a99:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a99
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a99:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a9a:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a9a
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a9a
.L_lambda_simple_env_end_0a9a:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a9a:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a9a
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a9a
.L_lambda_simple_params_end_0a9a:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a9a
	jmp .L_lambda_simple_end_0a9a
.L_lambda_simple_code_0a9a:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a9a
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a9a:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param str
	push rax
	push 1	; arg count
	mov rax, qword [free_var_119]	; free var string->list
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var char-case-converter
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_94]	; free var list->string
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef1:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef1
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef1
.L_tc_recycle_frame_done_0ef1:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a9a:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a99:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a9b:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a9b
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a9b
.L_lambda_simple_env_end_0a9b:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a9b:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a9b
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a9b
.L_lambda_simple_params_end_0a9b:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a9b
	jmp .L_lambda_simple_end_0a9b
.L_lambda_simple_code_0a9b:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a9b
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a9b:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, qword [free_var_71]	; free var char-downcase
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-string-case-converter
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_126], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_72]	; free var char-upcase
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-string-case-converter
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_132], rax
	mov rax, sob_void
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a9b:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_134], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_133], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_135], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_136], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_137], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_122], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_121], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_123], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_124], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rax, L_constants + 0
	mov qword [free_var_125], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a9c:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0a9c
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a9c
.L_lambda_simple_env_end_0a9c:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a9c:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0a9c
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a9c
.L_lambda_simple_params_end_0a9c:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a9c
	jmp .L_lambda_simple_end_0a9c
.L_lambda_simple_code_0a9c:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a9c
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a9c:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a9d:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0a9d
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a9d
.L_lambda_simple_env_end_0a9d:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a9d:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0a9d
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a9d
.L_lambda_simple_params_end_0a9d:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a9d
	jmp .L_lambda_simple_end_0a9d
.L_lambda_simple_code_0a9d:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0a9d
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a9d:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a9e:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a9e
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a9e
.L_lambda_simple_env_end_0a9e:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a9e:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a9e
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a9e
.L_lambda_simple_params_end_0a9e:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a9e
	jmp .L_lambda_simple_end_0a9e
.L_lambda_simple_code_0a9e:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 5
	je .L_lambda_simple_arity_check_ok_0a9e
	push qword [rsp + 8 * 2]
	push 5
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a9e:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param len1
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0803
	; preparing a non-tail-call
	mov rax, PARAM(4)	; param len2
	push rax
	mov rax, PARAM(2)	; param len1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0803
.L_if_else_0803:
	mov rax, L_constants + 2
.L_if_end_0803:
	cmp rax, sob_boolean_false
	jne .L_or_end_00e9
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param len1
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0805
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(3)	; param str2
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(1)	; param str1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var char<?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00ea
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(3)	; param str2
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(1)	; param str1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 1]	; bound var char=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0804
	; preparing a tail-call
	mov rax, PARAM(4)	; param len2
	push rax
	mov rax, PARAM(3)	; param str2
	push rax
	mov rax, PARAM(2)	; param len1
	push rax
	mov rax, PARAM(1)	; param str1
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef2:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef2
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef2
.L_tc_recycle_frame_done_0ef2:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0804
.L_if_else_0804:
	mov rax, L_constants + 2
.L_if_end_0804:
.L_or_end_00ea:
	jmp .L_if_end_0805
.L_if_else_0805:
	mov rax, L_constants + 2
.L_if_end_0805:
.L_or_end_00e9:
	leave
	ret AND_KILL_FRAME(5)
.L_lambda_simple_end_0a9e:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0a9f:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0a9f
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0a9f
.L_lambda_simple_env_end_0a9f:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0a9f:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0a9f
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0a9f
.L_lambda_simple_params_end_0a9f:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0a9f
	jmp .L_lambda_simple_end_0a9f
.L_lambda_simple_code_0a9f:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0a9f
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0a9f:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param str2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param str1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa0:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0aa0
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa0
.L_lambda_simple_env_end_0aa0:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa0:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0aa0
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa0
.L_lambda_simple_params_end_0aa0:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa0
	jmp .L_lambda_simple_end_0aa0
.L_lambda_simple_code_0aa0:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0aa0
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa0:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param len2
	push rax
	mov rax, PARAM(0)	; param len1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_5]	; free var <=
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0806
	; preparing a tail-call
	mov rax, PARAM(1)	; param len2
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var str2
	push rax
	mov rax, PARAM(0)	; param len1
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str1
	push rax
	mov rax, L_constants + 2135
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef3:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef3
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef3
.L_tc_recycle_frame_done_0ef3:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0806
.L_if_else_0806:
	; preparing a tail-call
	mov rax, PARAM(0)	; param len1
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str1
	push rax
	mov rax, PARAM(1)	; param len2
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var str2
	push rax
	mov rax, L_constants + 2135
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef4:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef4
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef4
.L_tc_recycle_frame_done_0ef4:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_0806:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0aa0:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef5:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef5
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef5
.L_tc_recycle_frame_done_0ef5:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a9f:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa1:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0aa1
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa1
.L_lambda_simple_env_end_0aa1:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa1:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aa1
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa1
.L_lambda_simple_params_end_0aa1:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa1
	jmp .L_lambda_simple_end_0aa1
.L_lambda_simple_code_0aa1:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aa1
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa1:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa2:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0aa2
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa2
.L_lambda_simple_env_end_0aa2:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa2:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aa2
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa2
.L_lambda_simple_params_end_0aa2:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa2
	jmp .L_lambda_simple_end_0aa2
.L_lambda_simple_code_0aa2:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aa2
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa2:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 5	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa3:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 4
	je .L_lambda_simple_env_end_0aa3
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa3
.L_lambda_simple_env_end_0aa3:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa3:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aa3
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa3
.L_lambda_simple_params_end_0aa3:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa3
	jmp .L_lambda_simple_end_0aa3
.L_lambda_simple_code_0aa3:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0aa3
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa3:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00eb
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var binary-string<?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0807
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef6:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef6
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef6
.L_tc_recycle_frame_done_0ef6:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0807
.L_if_else_0807:
	mov rax, L_constants + 2
.L_if_end_0807:
.L_or_end_00eb:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0aa3:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 5	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_014f:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 4
	je .L_lambda_opt_env_end_014f
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_014f
.L_lambda_opt_env_end_014f:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_014f:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_014f
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_014f
.L_lambda_opt_params_end_014f:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_014f
	jmp .L_lambda_opt_end_014f
.L_lambda_opt_code_014f:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_014f
	jg .L_lambda_opt_arity_check_more_014f
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_014f:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef8:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef8
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef8
.L_tc_recycle_frame_done_0ef8:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_014f	; new closure is in rax
.L_lambda_opt_arity_check_more_014f:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_014f:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_014f
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_014f
.L_lambda_opt_stack_shrink_loop_exit_014f:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef7:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef7
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef7
.L_tc_recycle_frame_done_0ef7:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_014f:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aa2:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0ef9:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0ef9
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0ef9
.L_tc_recycle_frame_done_0ef9:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aa1:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0efa:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0efa
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0efa
.L_tc_recycle_frame_done_0efa:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0a9d:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0efb:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0efb
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0efb
.L_tc_recycle_frame_done_0efb:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0a9c:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa4:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0aa4
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa4
.L_lambda_simple_env_end_0aa4:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa4:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0aa4
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa4
.L_lambda_simple_params_end_0aa4:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa4
	jmp .L_lambda_simple_end_0aa4
.L_lambda_simple_code_0aa4:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aa4
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa4:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, qword [free_var_75]	; free var char=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_74]	; free var char<?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, PARAM(0)	; param make-string<?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_134], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_68]	; free var char-ci=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_67]	; free var char-ci<?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, PARAM(0)	; param make-string<?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_122], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_75]	; free var char=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_77]	; free var char>?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, PARAM(0)	; param make-string<?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_137], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_68]	; free var char-ci=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_70]	; free var char-ci>?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, PARAM(0)	; param make-string<?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_125], rax
	mov rax, sob_void
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aa4:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa5:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0aa5
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa5
.L_lambda_simple_env_end_0aa5:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa5:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0aa5
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa5
.L_lambda_simple_params_end_0aa5:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa5
	jmp .L_lambda_simple_end_0aa5
.L_lambda_simple_code_0aa5:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0aa5
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa5:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa6:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0aa6
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa6
.L_lambda_simple_env_end_0aa6:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa6:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0aa6
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa6
.L_lambda_simple_params_end_0aa6:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa6
	jmp .L_lambda_simple_end_0aa6
.L_lambda_simple_code_0aa6:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aa6
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa6:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa7:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0aa7
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa7
.L_lambda_simple_env_end_0aa7:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa7:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aa7
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa7
.L_lambda_simple_params_end_0aa7:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa7
	jmp .L_lambda_simple_end_0aa7
.L_lambda_simple_code_0aa7:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 5
	je .L_lambda_simple_arity_check_ok_0aa7
	push qword [rsp + 8 * 2]
	push 5
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa7:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param len1
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00ec
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(3)	; param str2
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(1)	; param str1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var char<?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00ec
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param len1
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0809
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(3)	; param str2
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(1)	; param str1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 1]	; bound var char=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0808
	; preparing a tail-call
	mov rax, PARAM(4)	; param len2
	push rax
	mov rax, PARAM(3)	; param str2
	push rax
	mov rax, PARAM(2)	; param len1
	push rax
	mov rax, PARAM(1)	; param str1
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0efc:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0efc
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0efc
.L_tc_recycle_frame_done_0efc:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0808
.L_if_else_0808:
	mov rax, L_constants + 2
.L_if_end_0808:
	jmp .L_if_end_0809
.L_if_else_0809:
	mov rax, L_constants + 2
.L_if_end_0809:
.L_or_end_00ec:
	leave
	ret AND_KILL_FRAME(5)
.L_lambda_simple_end_0aa7:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa8:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0aa8
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa8
.L_lambda_simple_env_end_0aa8:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa8:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aa8
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa8
.L_lambda_simple_params_end_0aa8:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa8
	jmp .L_lambda_simple_end_0aa8
.L_lambda_simple_code_0aa8:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0aa8
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa8:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param str2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param str1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aa9:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0aa9
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aa9
.L_lambda_simple_env_end_0aa9:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aa9:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0aa9
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aa9
.L_lambda_simple_params_end_0aa9:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aa9
	jmp .L_lambda_simple_end_0aa9
.L_lambda_simple_code_0aa9:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0aa9
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aa9:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param len2
	push rax
	mov rax, PARAM(0)	; param len1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_5]	; free var <=
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_080a
	; preparing a tail-call
	mov rax, PARAM(1)	; param len2
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var str2
	push rax
	mov rax, PARAM(0)	; param len1
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str1
	push rax
	mov rax, L_constants + 2135
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0efd:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0efd
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0efd
.L_tc_recycle_frame_done_0efd:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_080a
.L_if_else_080a:
	; preparing a tail-call
	mov rax, PARAM(0)	; param len1
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str1
	push rax
	mov rax, PARAM(1)	; param len2
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var str2
	push rax
	mov rax, L_constants + 2135
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0efe:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0efe
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0efe
.L_tc_recycle_frame_done_0efe:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_080a:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0aa9:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0eff:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0eff
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0eff
.L_tc_recycle_frame_done_0eff:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0aa8:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aaa:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0aaa
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aaa
.L_lambda_simple_env_end_0aaa:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aaa:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aaa
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aaa
.L_lambda_simple_params_end_0aaa:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aaa
	jmp .L_lambda_simple_end_0aaa
.L_lambda_simple_code_0aaa:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aaa
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aaa:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aab:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0aab
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aab
.L_lambda_simple_env_end_0aab:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aab:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aab
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aab
.L_lambda_simple_params_end_0aab:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aab
	jmp .L_lambda_simple_end_0aab
.L_lambda_simple_code_0aab:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aab
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aab:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 5	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aac:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 4
	je .L_lambda_simple_env_end_0aac
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aac
.L_lambda_simple_env_end_0aac:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aac:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aac
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aac
.L_lambda_simple_params_end_0aac:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aac
	jmp .L_lambda_simple_end_0aac
.L_lambda_simple_code_0aac:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0aac
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aac:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00ed
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var binary-string<=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_080b
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f00:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f00
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f00
.L_tc_recycle_frame_done_0f00:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_080b
.L_if_else_080b:
	mov rax, L_constants + 2
.L_if_end_080b:
.L_or_end_00ed:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0aac:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 5	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0150:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 4
	je .L_lambda_opt_env_end_0150
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0150
.L_lambda_opt_env_end_0150:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0150:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0150
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0150
.L_lambda_opt_params_end_0150:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0150
	jmp .L_lambda_opt_end_0150
.L_lambda_opt_code_0150:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0150
	jg .L_lambda_opt_arity_check_more_0150
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0150:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f02:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f02
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f02
.L_tc_recycle_frame_done_0f02:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0150	; new closure is in rax
.L_lambda_opt_arity_check_more_0150:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0150:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0150
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0150
.L_lambda_opt_stack_shrink_loop_exit_0150:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f01:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f01
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f01
.L_tc_recycle_frame_done_0f01:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0150:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aab:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f03:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f03
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f03
.L_tc_recycle_frame_done_0f03:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aaa:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f04:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f04
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f04
.L_tc_recycle_frame_done_0f04:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aa6:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f05:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f05
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f05
.L_tc_recycle_frame_done_0f05:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0aa5:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aad:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0aad
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aad
.L_lambda_simple_env_end_0aad:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aad:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0aad
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aad
.L_lambda_simple_params_end_0aad:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aad
	jmp .L_lambda_simple_end_0aad
.L_lambda_simple_code_0aad:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aad
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aad:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, qword [free_var_75]	; free var char=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_74]	; free var char<?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, PARAM(0)	; param make-string<=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_133], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_68]	; free var char-ci=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_67]	; free var char-ci<?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, PARAM(0)	; param make-string<=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_121], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_75]	; free var char=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_77]	; free var char>?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, PARAM(0)	; param make-string<=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_136], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_68]	; free var char-ci=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	mov rax, qword [free_var_70]	; free var char-ci>?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, PARAM(0)	; param make-string<=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_124], rax
	mov rax, sob_void
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aad:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aae:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0aae
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aae
.L_lambda_simple_env_end_0aae:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aae:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0aae
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aae
.L_lambda_simple_params_end_0aae:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aae
	jmp .L_lambda_simple_end_0aae
.L_lambda_simple_code_0aae:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aae
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aae:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aaf:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0aaf
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aaf
.L_lambda_simple_env_end_0aaf:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aaf:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aaf
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aaf
.L_lambda_simple_params_end_0aaf:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aaf
	jmp .L_lambda_simple_end_0aaf
.L_lambda_simple_code_0aaf:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aaf
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aaf:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab0:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ab0
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab0
.L_lambda_simple_env_end_0ab0:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab0:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ab0
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab0
.L_lambda_simple_params_end_0ab0:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab0
	jmp .L_lambda_simple_end_0ab0
.L_lambda_simple_code_0ab0:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 4
	je .L_lambda_simple_arity_check_ok_0ab0
	push qword [rsp + 8 * 2]
	push 4
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab0:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(3)	; param len
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00ee
	; preparing a non-tail-call
	mov rax, PARAM(3)	; param len
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_080d
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(2)	; param str2
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, PARAM(1)	; param str1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var char=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_080c
	; preparing a tail-call
	mov rax, PARAM(3)	; param len
	push rax
	mov rax, PARAM(2)	; param str2
	push rax
	mov rax, PARAM(1)	; param str1
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 4	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f06:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f06
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f06
.L_tc_recycle_frame_done_0f06:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_080c
.L_if_else_080c:
	mov rax, L_constants + 2
.L_if_end_080c:
	jmp .L_if_end_080d
.L_if_else_080d:
	mov rax, L_constants + 2
.L_if_end_080d:
.L_or_end_00ee:
	leave
	ret AND_KILL_FRAME(4)
.L_lambda_simple_end_0ab0:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	; preparing a tail-call
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab1:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ab1
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab1
.L_lambda_simple_env_end_0ab1:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab1:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ab1
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab1
.L_lambda_simple_params_end_0ab1:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab1
	jmp .L_lambda_simple_end_0ab1
.L_lambda_simple_code_0ab1:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0ab1
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab1:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param str2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param str1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab2:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0ab2
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab2
.L_lambda_simple_env_end_0ab2:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab2:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0ab2
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab2
.L_lambda_simple_params_end_0ab2:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab2
	jmp .L_lambda_simple_end_0ab2
.L_lambda_simple_code_0ab2:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0ab2
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab2:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param len2
	push rax
	mov rax, PARAM(0)	; param len1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_080e
	; preparing a tail-call
	mov rax, PARAM(0)	; param len1
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var str2
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str1
	push rax
	mov rax, L_constants + 2135
	push rax
	push 4	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f07:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f07
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f07
.L_tc_recycle_frame_done_0f07:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_080e
.L_if_else_080e:
	mov rax, L_constants + 2
.L_if_end_080e:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0ab2:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f08:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f08
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f08
.L_tc_recycle_frame_done_0f08:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0ab1:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab3:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ab3
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab3
.L_lambda_simple_env_end_0ab3:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab3:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ab3
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab3
.L_lambda_simple_params_end_0ab3:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab3
	jmp .L_lambda_simple_end_0ab3
.L_lambda_simple_code_0ab3:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ab3
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab3:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab4:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0ab4
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab4
.L_lambda_simple_env_end_0ab4:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab4:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ab4
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab4
.L_lambda_simple_params_end_0ab4:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab4
	jmp .L_lambda_simple_end_0ab4
.L_lambda_simple_code_0ab4:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ab4
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab4:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 5	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab5:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 4
	je .L_lambda_simple_env_end_0ab5
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab5
.L_lambda_simple_env_end_0ab5:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab5:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ab5
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab5
.L_lambda_simple_params_end_0ab5:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab5
	jmp .L_lambda_simple_end_0ab5
.L_lambda_simple_code_0ab5:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0ab5
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab5:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00ef
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var binary-string=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_080f
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f09:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f09
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f09
.L_tc_recycle_frame_done_0f09:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_080f
.L_if_else_080f:
	mov rax, L_constants + 2
.L_if_end_080f:
.L_or_end_00ef:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0ab5:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 5	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0151:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 4
	je .L_lambda_opt_env_end_0151
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0151
.L_lambda_opt_env_end_0151:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0151:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0151
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0151
.L_lambda_opt_params_end_0151:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0151
	jmp .L_lambda_opt_end_0151
.L_lambda_opt_code_0151:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0151
	jg .L_lambda_opt_arity_check_more_0151
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0151:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f0b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f0b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f0b
.L_tc_recycle_frame_done_0f0b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0151	; new closure is in rax
.L_lambda_opt_arity_check_more_0151:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0151:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0151
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0151
.L_lambda_opt_stack_shrink_loop_exit_0151:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(1)	; param strs
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f0a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f0a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f0a
.L_tc_recycle_frame_done_0f0a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0151:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ab4:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f0c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f0c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f0c
.L_tc_recycle_frame_done_0f0c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ab3:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f0d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f0d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f0d
.L_tc_recycle_frame_done_0f0d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aaf:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f0e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f0e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f0e
.L_tc_recycle_frame_done_0f0e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aae:	; new closure is in rax
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab6:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ab6
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab6
.L_lambda_simple_env_end_0ab6:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab6:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ab6
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab6
.L_lambda_simple_params_end_0ab6:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab6
	jmp .L_lambda_simple_end_0ab6
.L_lambda_simple_code_0ab6:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ab6
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab6:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, qword [free_var_75]	; free var char=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-string=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_135], rax
	mov rax, sob_void

	; preparing a non-tail-call
	mov rax, qword [free_var_68]	; free var char-ci=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param make-string=?
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_123], rax
	mov rax, sob_void
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ab6:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab7:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ab7
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab7
.L_lambda_simple_env_end_0ab7:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab7:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ab7
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab7
.L_lambda_simple_params_end_0ab7:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab7
	jmp .L_lambda_simple_end_0ab7
.L_lambda_simple_code_0ab7:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ab7
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab7:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	jne .L_or_end_00f0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0810
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_96]	; free var list?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f0f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f0f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f0f
.L_tc_recycle_frame_done_0f0f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0810
.L_if_else_0810:
	mov rax, L_constants + 2
.L_if_end_0810:
.L_or_end_00f0:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ab7:	; new closure is in rax
	mov qword [free_var_96], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, qword [free_var_101]	; free var make-vector
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab8:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ab8
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab8
.L_lambda_simple_env_end_0ab8:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab8:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ab8
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab8
.L_lambda_simple_params_end_0ab8:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab8
	jmp .L_lambda_simple_end_0ab8
.L_lambda_simple_code_0ab8:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ab8
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab8:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0152:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0152
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0152
.L_lambda_opt_env_end_0152:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0152:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0152
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0152
.L_lambda_opt_params_end_0152:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0152
	jmp .L_lambda_opt_end_0152
.L_lambda_opt_code_0152:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0152
	jg .L_lambda_opt_arity_check_more_0152
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0152:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param xs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0816
	mov rax, L_constants + 0
	jmp .L_if_end_0816
.L_if_else_0816:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param xs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0814
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param xs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0814
.L_if_else_0814:
	mov rax, L_constants + 2
.L_if_end_0814:
	cmp rax, sob_boolean_false
	je .L_if_else_0815
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param xs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0815
.L_if_else_0815:
	; preparing a non-tail-call
	mov rax, L_constants + 2955
	push rax
	mov rax, L_constants + 2946
	push rax
	push 2	; arg count
	mov rax, qword [free_var_82]	; free var error
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
.L_if_end_0815:
.L_if_end_0816:
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aba:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0aba
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aba
.L_lambda_simple_env_end_0aba:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aba:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0aba
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aba
.L_lambda_simple_params_end_0aba:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aba
	jmp .L_lambda_simple_end_0aba
.L_lambda_simple_code_0aba:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aba
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aba:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param x
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var n
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var asm-make-vector
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f12:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f12
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f12
.L_tc_recycle_frame_done_0f12:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aba:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f13:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f13
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f13
.L_tc_recycle_frame_done_0f13:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0152	; new closure is in rax
.L_lambda_opt_arity_check_more_0152:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0152:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0152
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0152
.L_lambda_opt_stack_shrink_loop_exit_0152:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param xs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0813
	mov rax, L_constants + 0
	jmp .L_if_end_0813
.L_if_else_0813:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param xs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0811
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param xs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0811
.L_if_else_0811:
	mov rax, L_constants + 2
.L_if_end_0811:
	cmp rax, sob_boolean_false
	je .L_if_else_0812
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param xs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0812
.L_if_else_0812:
	; preparing a non-tail-call
	mov rax, L_constants + 2955
	push rax
	mov rax, L_constants + 2946
	push rax
	push 2	; arg count
	mov rax, qword [free_var_82]	; free var error
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
.L_if_end_0812:
.L_if_end_0813:
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ab9:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ab9
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ab9
.L_lambda_simple_env_end_0ab9:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ab9:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0ab9
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ab9
.L_lambda_simple_params_end_0ab9:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ab9
	jmp .L_lambda_simple_end_0ab9
.L_lambda_simple_code_0ab9:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ab9
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ab9:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param x
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var n
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var asm-make-vector
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f10:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f10
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f10
.L_tc_recycle_frame_done_0f10:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ab9:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f11:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f11
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f11
.L_tc_recycle_frame_done_0f11:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0152:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ab8:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_101], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, qword [free_var_99]	; free var make-string
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0abb:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0abb
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0abb
.L_lambda_simple_env_end_0abb:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0abb:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0abb
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0abb
.L_lambda_simple_params_end_0abb:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0abb
	jmp .L_lambda_simple_end_0abb
.L_lambda_simple_code_0abb:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0abb
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0abb:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0153:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0153
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0153
.L_lambda_opt_env_end_0153:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0153:	; copy params
	cmp rsi, 1
	je .L_lambda_opt_params_end_0153
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0153
.L_lambda_opt_params_end_0153:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0153
	jmp .L_lambda_opt_end_0153
.L_lambda_opt_code_0153:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_opt_arity_check_exact_0153
	jg .L_lambda_opt_arity_check_more_0153
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0153:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 2
	mov qword[rsp + 8 *2], rax
	mov rax, qword[rsp + 8 * (4 + 0)]
	mov qword[rsp + 8 * (3 + 0)], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 1)], rax
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param chs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_081c
	mov rax, L_constants + 4
	jmp .L_if_end_081c
.L_if_else_081c:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param chs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_081a
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param chs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_081a
.L_if_else_081a:
	mov rax, L_constants + 2
.L_if_end_081a:
	cmp rax, sob_boolean_false
	je .L_if_else_081b
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param chs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_081b
.L_if_else_081b:
	; preparing a non-tail-call
	mov rax, L_constants + 3016
	push rax
	mov rax, L_constants + 3007
	push rax
	push 2	; arg count
	mov rax, qword [free_var_82]	; free var error
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
.L_if_end_081b:
.L_if_end_081c:
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0abd:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0abd
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0abd
.L_lambda_simple_env_end_0abd:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0abd:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0abd
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0abd
.L_lambda_simple_params_end_0abd:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0abd
	jmp .L_lambda_simple_end_0abd
.L_lambda_simple_code_0abd:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0abd
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0abd:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param ch
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var n
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var asm-make-string
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f16:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f16
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f16
.L_tc_recycle_frame_done_0f16:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0abd:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f17:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f17
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f17
.L_tc_recycle_frame_done_0f17:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
	jmp .L_lambda_opt_end_0153	; new closure is in rax
.L_lambda_opt_arity_check_more_0153:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0153:
	cmp r8, 1
	je .L_lambda_opt_stack_shrink_loop_exit_0153
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0153
.L_lambda_opt_stack_shrink_loop_exit_0153:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 2
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 1;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov r8, qword [rbx] 	;r8 is holding the param to copy
	mov qword[rax], r8
	sub rax, 8
	sub rbx, 8
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 2
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param chs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0819
	mov rax, L_constants + 4
	jmp .L_if_end_0819
.L_if_else_0819:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param chs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0817
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param chs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0817
.L_if_else_0817:
	mov rax, L_constants + 2
.L_if_end_0817:
	cmp rax, sob_boolean_false
	je .L_if_else_0818
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param chs
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0818
.L_if_else_0818:
	; preparing a non-tail-call
	mov rax, L_constants + 3016
	push rax
	mov rax, L_constants + 3007
	push rax
	push 2	; arg count
	mov rax, qword [free_var_82]	; free var error
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
.L_if_end_0818:
.L_if_end_0819:
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0abc:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0abc
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0abc
.L_lambda_simple_env_end_0abc:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0abc:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0abc
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0abc
.L_lambda_simple_params_end_0abc:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0abc
	jmp .L_lambda_simple_end_0abc
.L_lambda_simple_code_0abc:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0abc
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0abc:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param ch
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var n
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var asm-make-string
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f14:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f14
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f14
.L_tc_recycle_frame_done_0f14:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0abc:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f15:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f15
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f15
.L_tc_recycle_frame_done_0f15:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_opt_end_0153:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0abb:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_99], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0abe:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0abe
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0abe
.L_lambda_simple_env_end_0abe:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0abe:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0abe
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0abe
.L_lambda_simple_params_end_0abe:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0abe
	jmp .L_lambda_simple_end_0abe
.L_lambda_simple_code_0abe:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0abe
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0abe:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0abf:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0abf
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0abf
.L_lambda_simple_env_end_0abf:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0abf:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0abf
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0abf
.L_lambda_simple_params_end_0abf:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0abf
	jmp .L_lambda_simple_end_0abf
.L_lambda_simple_code_0abf:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0abf
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0abf:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_081d
	; preparing a tail-call
	mov rax, L_constants + 0
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_101]	; free var make-vector
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f18:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f18
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f18
.L_tc_recycle_frame_done_0f18:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_081d
.L_if_else_081d:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac0:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ac0
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac0
.L_lambda_simple_env_end_0ac0:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac0:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0ac0
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac0
.L_lambda_simple_params_end_0ac0:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac0
	jmp .L_lambda_simple_end_0ac0
.L_lambda_simple_code_0ac0:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ac0
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac0:
	enter 0, 0
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var i
	push rax
	mov rax, PARAM(0)	; param v
	push rax
	push 3	; arg count
	mov rax, qword [free_var_148]	; free var vector-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rax, PARAM(0)	; param v
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ac0:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f19:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f19
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f19
.L_tc_recycle_frame_done_0f19:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_081d:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0abf:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac1:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ac1
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac1
.L_lambda_simple_env_end_0ac1:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac1:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ac1
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac1
.L_lambda_simple_params_end_0ac1:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac1
	jmp .L_lambda_simple_end_0ac1
.L_lambda_simple_code_0ac1:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ac1
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac1:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 2135
	push rax
	mov rax, PARAM(0)	; param s
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f1a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f1a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f1a
.L_tc_recycle_frame_done_0f1a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ac1:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0abe:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_95], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac2:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ac2
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac2
.L_lambda_simple_env_end_0ac2:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac2:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ac2
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac2
.L_lambda_simple_params_end_0ac2:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac2
	jmp .L_lambda_simple_end_0ac2
.L_lambda_simple_code_0ac2:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ac2
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac2:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac3:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ac3
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac3
.L_lambda_simple_env_end_0ac3:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac3:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ac3
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac3
.L_lambda_simple_params_end_0ac3:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac3
	jmp .L_lambda_simple_end_0ac3
.L_lambda_simple_code_0ac3:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0ac3
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac3:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_081e
	; preparing a tail-call
	mov rax, L_constants + 4
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_99]	; free var make-string
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f1b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f1b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f1b
.L_tc_recycle_frame_done_0f1b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_081e
.L_if_else_081e:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac4:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ac4
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac4
.L_lambda_simple_env_end_0ac4:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac4:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0ac4
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac4
.L_lambda_simple_params_end_0ac4:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac4
	jmp .L_lambda_simple_end_0ac4
.L_lambda_simple_code_0ac4:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ac4
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac4:
	enter 0, 0
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var i
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 3	; arg count
	mov rax, qword [free_var_131]	; free var string-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	mov rax, PARAM(0)	; param str
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ac4:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f1c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f1c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f1c
.L_tc_recycle_frame_done_0f1c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_081e:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0ac3:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac5:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ac5
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac5
.L_lambda_simple_env_end_0ac5:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac5:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ac5
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac5
.L_lambda_simple_params_end_0ac5:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac5
	jmp .L_lambda_simple_end_0ac5
.L_lambda_simple_code_0ac5:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ac5
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac5:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 2135
	push rax
	mov rax, PARAM(0)	; param s
	push rax
	push 2	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f1d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f1d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f1d
.L_tc_recycle_frame_done_0f1d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ac5:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ac2:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_94], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0154:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_opt_env_end_0154
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0154
.L_lambda_opt_env_end_0154:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0154:	; copy params
	cmp rsi, 0
	je .L_lambda_opt_params_end_0154
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0154
.L_lambda_opt_params_end_0154:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0154
	jmp .L_lambda_opt_end_0154
.L_lambda_opt_code_0154:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_opt_arity_check_exact_0154
	jg .L_lambda_opt_arity_check_more_0154
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0154:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 1
	mov qword[rsp + 8 *2], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 0)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_95]	; free var list->vector
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f1f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f1f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f1f
.L_tc_recycle_frame_done_0f1f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
	jmp .L_lambda_opt_end_0154	; new closure is in rax
.L_lambda_opt_arity_check_more_0154:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0154:
	cmp r8, 0
	je .L_lambda_opt_stack_shrink_loop_exit_0154
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0154
.L_lambda_opt_stack_shrink_loop_exit_0154:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 1
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 0;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 1
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_95]	; free var list->vector
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f1e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f1e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f1e
.L_tc_recycle_frame_done_0f1e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_opt_end_0154:	; new closure is in rax
	mov qword [free_var_141], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac6:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ac6
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac6
.L_lambda_simple_env_end_0ac6:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac6:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ac6
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac6
.L_lambda_simple_params_end_0ac6:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac6
	jmp .L_lambda_simple_end_0ac6
.L_lambda_simple_code_0ac6:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ac6
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac6:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac7:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ac7
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac7
.L_lambda_simple_env_end_0ac7:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac7:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ac7
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac7
.L_lambda_simple_params_end_0ac7:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac7
	jmp .L_lambda_simple_end_0ac7
.L_lambda_simple_code_0ac7:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0ac7
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac7:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param n
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_081f
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param n
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param i
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f20:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f20
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f20
.L_tc_recycle_frame_done_0f20:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_081f
.L_if_else_081f:
	mov rax, L_constants + 1
.L_if_end_081f:
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0ac7:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac8:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ac8
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac8
.L_lambda_simple_env_end_0ac8:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac8:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ac8
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac8
.L_lambda_simple_params_end_0ac8:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac8
	jmp .L_lambda_simple_end_0ac8
.L_lambda_simple_code_0ac8:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ac8
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac8:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param str
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, L_constants + 2135
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f21:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f21
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f21
.L_tc_recycle_frame_done_0f21:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ac8:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ac6:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_119], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ac9:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ac9
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ac9
.L_lambda_simple_env_end_0ac9:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ac9:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ac9
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ac9
.L_lambda_simple_params_end_0ac9:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ac9
	jmp .L_lambda_simple_end_0ac9
.L_lambda_simple_code_0ac9:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ac9
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ac9:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aca:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0aca
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aca
.L_lambda_simple_env_end_0aca:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aca:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aca
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aca
.L_lambda_simple_params_end_0aca:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aca
	jmp .L_lambda_simple_end_0aca
.L_lambda_simple_code_0aca:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0aca
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aca:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param n
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0820
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param n
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param v
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param i
	push rax
	mov rax, PARAM(0)	; param v
	push rax
	push 2	; arg count
	mov rax, qword [free_var_145]	; free var vector-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f22:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f22
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f22
.L_tc_recycle_frame_done_0f22:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0820
.L_if_else_0820:
	mov rax, L_constants + 1
.L_if_end_0820:
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0aca:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0acb:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0acb
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0acb
.L_lambda_simple_env_end_0acb:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0acb:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0acb
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0acb
.L_lambda_simple_params_end_0acb:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0acb
	jmp .L_lambda_simple_end_0acb
.L_lambda_simple_code_0acb:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0acb
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0acb:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param v
	push rax
	push 1	; arg count
	mov rax, qword [free_var_144]	; free var vector-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, L_constants + 2135
	push rax
	mov rax, PARAM(0)	; param v
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f23:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f23
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f23
.L_tc_recycle_frame_done_0f23:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0acb:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ac9:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_142], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0acc:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0acc
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0acc
.L_lambda_simple_env_end_0acc:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0acc:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0acc
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0acc
.L_lambda_simple_params_end_0acc:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0acc
	jmp .L_lambda_simple_end_0acc
.L_lambda_simple_code_0acc:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0acc
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0acc:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param n
	push rax
	; preparing a non-tail-call
	push 0	; arg count
	mov rax, qword [free_var_140]	; free var trng
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_117]	; free var remainder
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f24:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f24
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f24
.L_tc_recycle_frame_done_0f24:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0acc:	; new closure is in rax
	mov qword [free_var_113], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0acd:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0acd
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0acd
.L_lambda_simple_env_end_0acd:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0acd:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0acd
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0acd
.L_lambda_simple_params_end_0acd:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0acd
	jmp .L_lambda_simple_end_0acd
.L_lambda_simple_code_0acd:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0acd
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0acd:
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param x
	push rax
	mov rax, L_constants + 2135
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f25:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f25
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f25
.L_tc_recycle_frame_done_0f25:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0acd:	; new closure is in rax
	mov qword [free_var_112], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ace:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ace
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ace
.L_lambda_simple_env_end_0ace:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ace:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ace
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ace
.L_lambda_simple_params_end_0ace:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ace
	jmp .L_lambda_simple_end_0ace
.L_lambda_simple_code_0ace:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ace
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ace:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 2135
	push rax
	mov rax, PARAM(0)	; param x
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f26:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f26
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f26
.L_tc_recycle_frame_done_0f26:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ace:	; new closure is in rax
	mov qword [free_var_104], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0acf:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0acf
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0acf
.L_lambda_simple_env_end_0acf:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0acf:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0acf
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0acf
.L_lambda_simple_params_end_0acf:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0acf
	jmp .L_lambda_simple_end_0acf
.L_lambda_simple_code_0acf:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0acf
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0acf:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 3190
	push rax
	mov rax, PARAM(0)	; param n
	push rax
	push 2	; arg count
	mov rax, qword [free_var_117]	; free var remainder
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_152]	; free var zero?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f27:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f27
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f27
.L_tc_recycle_frame_done_0f27:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0acf:	; new closure is in rax
	mov qword [free_var_83], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad0:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ad0
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad0
.L_lambda_simple_env_end_0ad0:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad0:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ad0
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad0
.L_lambda_simple_params_end_0ad0:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad0
	jmp .L_lambda_simple_end_0ad0
.L_lambda_simple_code_0ad0:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ad0
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad0:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param n
	push rax
	push 1	; arg count
	mov rax, qword [free_var_83]	; free var even?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_106]	; free var not
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f28:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f28
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f28
.L_tc_recycle_frame_done_0f28:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ad0:	; new closure is in rax
	mov qword [free_var_109], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad1:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ad1
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad1
.L_lambda_simple_env_end_0ad1:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad1:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ad1
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad1
.L_lambda_simple_params_end_0ad1:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad1
	jmp .L_lambda_simple_end_0ad1
.L_lambda_simple_code_0ad1:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ad1
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad1:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_104]	; free var negative?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0821
	; preparing a tail-call
	mov rax, PARAM(0)	; param x
	push rax
	push 1	; arg count
	mov rax, qword [free_var_2]	; free var -
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f29:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f29
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f29
.L_tc_recycle_frame_done_0f29:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0821
.L_if_else_0821:
	mov rax, PARAM(0)	; param x
.L_if_end_0821:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ad1:	; new closure is in rax
	mov qword [free_var_30], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad2:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ad2
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad2
.L_lambda_simple_env_end_0ad2:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad2:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ad2
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad2
.L_lambda_simple_params_end_0ad2:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad2
	jmp .L_lambda_simple_end_0ad2
.L_lambda_simple_code_0ad2:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0ad2
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad2:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0822
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_111]	; free var pair?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0822
.L_if_else_0822:
	mov rax, L_constants + 2
.L_if_end_0822:
	cmp rax, sob_boolean_false
	je .L_if_else_082e
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_81]	; free var equal?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0823
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_81]	; free var equal?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f2a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f2a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f2a
.L_tc_recycle_frame_done_0f2a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0823
.L_if_else_0823:
	mov rax, L_constants + 2
.L_if_end_0823:
	jmp .L_if_end_082e
.L_if_else_082e:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_149]	; free var vector?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0825
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_149]	; free var vector?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0824
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_144]	; free var vector-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_144]	; free var vector-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0824
.L_if_else_0824:
	mov rax, L_constants + 2
.L_if_end_0824:
	jmp .L_if_end_0825
.L_if_else_0825:
	mov rax, L_constants + 2
.L_if_end_0825:
	cmp rax, sob_boolean_false
	je .L_if_else_082d
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_142]	; free var vector->list
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_142]	; free var vector->list
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_81]	; free var equal?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f2b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f2b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f2b
.L_tc_recycle_frame_done_0f2b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_082d
.L_if_else_082d:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_138]	; free var string?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0827
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_138]	; free var string?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0826
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0826
.L_if_else_0826:
	mov rax, L_constants + 2
.L_if_end_0826:
	jmp .L_if_end_0827
.L_if_else_0827:
	mov rax, L_constants + 2
.L_if_end_0827:
	cmp rax, sob_boolean_false
	je .L_if_else_082c
	; preparing a tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	mov rax, PARAM(0)	; param e1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_135]	; free var string=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f2c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f2c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f2c
.L_tc_recycle_frame_done_0f2c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_082c
.L_if_else_082c:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_108]	; free var number?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0828
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_108]	; free var number?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0828
.L_if_else_0828:
	mov rax, L_constants + 2
.L_if_end_0828:
	cmp rax, sob_boolean_false
	je .L_if_else_082b
	; preparing a tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	mov rax, PARAM(0)	; param e1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f2d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f2d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f2d
.L_tc_recycle_frame_done_0f2d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_082b
.L_if_else_082b:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param e1
	push rax
	push 1	; arg count
	mov rax, qword [free_var_78]	; free var char?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0829
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	push 1	; arg count
	mov rax, qword [free_var_78]	; free var char?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0829
.L_if_else_0829:
	mov rax, L_constants + 2
.L_if_end_0829:
	cmp rax, sob_boolean_false
	je .L_if_else_082a
	; preparing a tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	mov rax, PARAM(0)	; param e1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_75]	; free var char=?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f2e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f2e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f2e
.L_tc_recycle_frame_done_0f2e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_082a
.L_if_else_082a:
	; preparing a tail-call
	mov rax, PARAM(1)	; param e2
	push rax
	mov rax, PARAM(0)	; param e1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_80]	; free var eq?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f2f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f2f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f2f
.L_tc_recycle_frame_done_0f2f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_082a:
.L_if_end_082b:
.L_if_end_082c:
.L_if_end_082d:
.L_if_end_082e:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0ad2:	; new closure is in rax
	mov qword [free_var_81], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad3:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ad3
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad3
.L_lambda_simple_env_end_0ad3:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad3:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ad3
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad3
.L_lambda_simple_params_end_0ad3:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad3
	jmp .L_lambda_simple_end_0ad3
.L_lambda_simple_code_0ad3:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0ad3
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad3:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0830
	mov rax, L_constants + 2
	jmp .L_if_end_0830
.L_if_else_0830:
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_41]	; free var caar
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_80]	; free var eq?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_082f
	; preparing a tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f30:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f30
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f30
.L_tc_recycle_frame_done_0f30:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_082f
.L_if_else_082f:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_34]	; free var assoc
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f31:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f31
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f31
.L_tc_recycle_frame_done_0f31:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_082f:
.L_if_end_0830:
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0ad3:	; new closure is in rax
	mov qword [free_var_34], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	mov rax, L_constants + 1993
	push rax
	push 2	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad4:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ad4
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad4
.L_lambda_simple_env_end_0ad4:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad4:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ad4
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad4
.L_lambda_simple_params_end_0ad4:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad4
	jmp .L_lambda_simple_end_0ad4
.L_lambda_simple_code_0ad4:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0ad4
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad4:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(1)
	mov qword[rax], rbx
	mov PARAM(1), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad5:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ad5
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad5
.L_lambda_simple_env_end_0ad5:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad5:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0ad5
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad5
.L_lambda_simple_params_end_0ad5:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad5
	jmp .L_lambda_simple_end_0ad5
.L_lambda_simple_code_0ad5:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0ad5
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad5:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0831
	mov rax, PARAM(0)	; param target
	jmp .L_if_end_0831
.L_if_else_0831:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, L_constants + 2135
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	mov rax, PARAM(0)	; param target
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var add
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 3	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad6:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ad6
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad6
.L_lambda_simple_env_end_0ad6:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad6:	; copy params
	cmp rsi, 3
	je .L_lambda_simple_params_end_0ad6
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad6
.L_lambda_simple_params_end_0ad6:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad6
	jmp .L_lambda_simple_end_0ad6
.L_lambda_simple_code_0ad6:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ad6
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad6:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var target
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f32:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f32
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f32
.L_tc_recycle_frame_done_0f32:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ad6:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f33:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f33
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f33
.L_tc_recycle_frame_done_0f33:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_0831:
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0ad5:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad7:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ad7
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad7
.L_lambda_simple_env_end_0ad7:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad7:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0ad7
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad7
.L_lambda_simple_params_end_0ad7:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad7
	jmp .L_lambda_simple_end_0ad7
.L_lambda_simple_code_0ad7:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 5
	je .L_lambda_simple_arity_check_ok_0ad7
	push qword [rsp + 8 * 2]
	push 5
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad7:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(4)	; param limit
	push rax
	mov rax, PARAM(3)	; param j
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0832
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(3)	; param j
	push rax
	mov rax, PARAM(2)	; param str
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	mov rax, PARAM(0)	; param target
	push rax
	push 3	; arg count
	mov rax, qword [free_var_131]	; free var string-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	; preparing a tail-call
	mov rax, PARAM(4)	; param limit
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(3)	; param j
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(2)	; param str
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param target
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var add
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f34:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f34
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f34
.L_tc_recycle_frame_done_0f34:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0832
.L_if_else_0832:
	mov rax, PARAM(1)	; param i
.L_if_end_0832:
	leave
	ret AND_KILL_FRAME(5)
.L_lambda_simple_end_0ad7:	; new closure is in rax
	push rax
	mov rax, PARAM(1)	; param add
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0155:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0155
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0155
.L_lambda_opt_env_end_0155:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0155:	; copy params
	cmp rsi, 2
	je .L_lambda_opt_params_end_0155
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0155
.L_lambda_opt_params_end_0155:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0155
	jmp .L_lambda_opt_end_0155
.L_lambda_opt_code_0155:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_opt_arity_check_exact_0155
	jg .L_lambda_opt_arity_check_more_0155
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0155:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 1
	mov qword[rsp + 8 *2], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 0)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param strings
	push rax
	mov rax, L_constants + 2135
	push rax
	; preparing a non-tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param strings
	push rax
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_99]	; free var make-string
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f36:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f36
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f36
.L_tc_recycle_frame_done_0f36:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
	jmp .L_lambda_opt_end_0155	; new closure is in rax
.L_lambda_opt_arity_check_more_0155:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0155:
	cmp r8, 0
	je .L_lambda_opt_stack_shrink_loop_exit_0155
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0155
.L_lambda_opt_stack_shrink_loop_exit_0155:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 1
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 0;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 1
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param strings
	push rax
	mov rax, L_constants + 2135
	push rax
	; preparing a non-tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param strings
	push rax
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_99]	; free var make-string
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f35:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f35
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f35
.L_tc_recycle_frame_done_0f35:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_opt_end_0155:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0ad4:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_120], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	mov rax, L_constants + 1993
	push rax
	push 2	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad8:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ad8
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad8
.L_lambda_simple_env_end_0ad8:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad8:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ad8
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad8
.L_lambda_simple_params_end_0ad8:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad8
	jmp .L_lambda_simple_end_0ad8
.L_lambda_simple_code_0ad8:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0ad8
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad8:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(1)
	mov qword[rax], rbx
	mov PARAM(1), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ad9:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ad9
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ad9
.L_lambda_simple_env_end_0ad9:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ad9:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0ad9
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ad9
.L_lambda_simple_params_end_0ad9:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ad9
	jmp .L_lambda_simple_end_0ad9
.L_lambda_simple_code_0ad9:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0ad9
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ad9:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_107]	; free var null?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0833
	mov rax, PARAM(0)	; param target
	jmp .L_if_end_0833
.L_if_else_0833:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_144]	; free var vector-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, L_constants + 2135
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_49]	; free var car
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	mov rax, PARAM(0)	; param target
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var add
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 3	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ada:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ada
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ada
.L_lambda_simple_env_end_0ada:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ada:	; copy params
	cmp rsi, 3
	je .L_lambda_simple_params_end_0ada
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ada
.L_lambda_simple_params_end_0ada:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ada
	jmp .L_lambda_simple_end_0ada
.L_lambda_simple_code_0ada:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ada
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ada:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var s
	push rax
	push 1	; arg count
	mov rax, qword [free_var_64]	; free var cdr
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var target
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f37:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f37
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f37
.L_tc_recycle_frame_done_0f37:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ada:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f38:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f38
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f38
.L_tc_recycle_frame_done_0f38:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_0833:
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0ad9:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0adb:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0adb
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0adb
.L_lambda_simple_env_end_0adb:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0adb:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0adb
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0adb
.L_lambda_simple_params_end_0adb:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0adb
	jmp .L_lambda_simple_end_0adb
.L_lambda_simple_code_0adb:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 5
	je .L_lambda_simple_arity_check_ok_0adb
	push qword [rsp + 8 * 2]
	push 5
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0adb:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(4)	; param limit
	push rax
	mov rax, PARAM(3)	; param j
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0834
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(3)	; param j
	push rax
	mov rax, PARAM(2)	; param vec
	push rax
	push 2	; arg count
	mov rax, qword [free_var_145]	; free var vector-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	mov rax, PARAM(0)	; param target
	push rax
	push 3	; arg count
	mov rax, qword [free_var_148]	; free var vector-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	; preparing a tail-call
	mov rax, PARAM(4)	; param limit
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(3)	; param j
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(2)	; param vec
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param target
	push rax
	push 5	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var add
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f39:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f39
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f39
.L_tc_recycle_frame_done_0f39:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0834
.L_if_else_0834:
	mov rax, PARAM(1)	; param i
.L_if_end_0834:
	leave
	ret AND_KILL_FRAME(5)
.L_lambda_simple_end_0adb:	; new closure is in rax
	push rax
	mov rax, PARAM(1)	; param add
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_opt_env_loop_0156:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_opt_env_end_0156
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_opt_env_loop_0156
.L_lambda_opt_env_end_0156:
	pop rbx
	mov rsi, 0
.L_lambda_opt_params_loop_0156:	; copy params
	cmp rsi, 2
	je .L_lambda_opt_params_end_0156
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_opt_params_loop_0156
.L_lambda_opt_params_end_0156:
	mov qword [rax], rbx	 ;ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_opt_code_0156
	jmp .L_lambda_opt_end_0156
.L_lambda_opt_code_0156:	; lambda-opt body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_opt_arity_check_exact_0156
	jg .L_lambda_opt_arity_check_more_0156
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_opt
.L_lambda_opt_arity_check_exact_0156:
	sub rsp, 8
	mov rax, qword[rsp + 8 *1]
	mov qword[rsp], rax  
	mov rax, qword[rsp + 8 *2] ;rax now holds env 
	mov qword[rsp + 8 * 1], rax
	mov rax, 1
	mov qword[rsp + 8 *2], rax
	mov rax, sob_nil
	mov qword[rsp + 8 * (3 + 0)], rax
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param vectors
	push rax
	mov rax, L_constants + 2135
	push rax
	; preparing a non-tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param vectors
	push rax
	mov rax, qword [free_var_144]	; free var vector-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_101]	; free var make-vector
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f3b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f3b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f3b
.L_tc_recycle_frame_done_0f3b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
	jmp .L_lambda_opt_end_0156	; new closure is in rax
.L_lambda_opt_arity_check_more_0156:
	mov r8, qword[rsp + 2 * 8]	;;rax is holding arg count
	mov r9, sob_nil
	mov rbx, rsp 
	add rbx, 3*8 	; now rbx is pointing to the first param
	dec r8	 ;to get to the top - starting at 0 not 1
	shl r8, 3
	add rbx, r8	 ;rbx now points to the last opt param that was pushed
	mov r8, qword[rsp + 2* 8]	;r8 is our loop counter
.L_lambda_opt_stack_shrink_loop_0156:
	cmp r8, 0
	je .L_lambda_opt_stack_shrink_loop_exit_0156
	mov rdi, 1+8+8 ;for pair
	call malloc;to create the pair in the stack
	mov byte [rax], T_pair ; to make it a pair
	mov rcx, qword[rbx] ;rcx is holding the param to copy
	mov qword[rax+1], rcx ;put the car in the last (not inside of the list yet) in the pair
 	mov qword[rax+1+8],r9
	mov r9, rax ;for the recursion 
	dec r8 ;we finished copy another opt param to the list
	sub rbx, 8 ;to get the next param to copy
	jmp .L_lambda_opt_stack_shrink_loop_0156
.L_lambda_opt_stack_shrink_loop_exit_0156:
	mov rcx, qword[rsp + 2 * 8] ;rcx is holding the total number of params including opt
	sub rcx, 1
	shl rcx, 3 ;rcx is now holding in how much bytes e need to shrink the stack
	add rsp, rcx ;shrinking the stack
	mov rax, rsp
	sub rax, rcx ;now rax is pointing on the original ret
	mov r8, qword[rax + 2 * 8] ;r8 is holding the arg count including opt
	dec r8 ;we start with param 0, not 1 
	add rax, 3 * 8;now rax is param 0
	shl r8, 3;convert to byte
	add rax, r8;now rax is the top of the stack
	mov qword[rax], r9;puting the list at the top
	sub rax, 8;rax is the adress to copy to the not optional params
	mov rbx, rsp 
	sub rbx, rcx;rbx is the ret adress in the original
	mov r10, 0;r10 is the not opt params length
	dec r10 
	shl r10, 3;to get bytes
	add rbx, 3*8;rbx is the first param
	add rbx, r10; rbx is where the address to copy to
	mov rax, rsp
	sub rax, rcx 	 ;now rax is original ret
	mov qword [rsp+2*8], 1
	mov rbx, qword[rax + 8 *1]
	mov qword [rsp + 1*8] ,rbx
	mov rbx, qword[rax]
	mov qword [rsp], rbx
	enter 0, 0
	; preparing a tail-call
	mov rax, PARAM(0)	; param vectors
	push rax
	mov rax, L_constants + 2135
	push rax
	; preparing a non-tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param vectors
	push rax
	mov rax, qword [free_var_144]	; free var vector-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_103]	; free var map
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_101]	; free var make-vector
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f3a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f3a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f3a
.L_tc_recycle_frame_done_0f3a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_opt_end_0156:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0ad8:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_143], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0adc:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0adc
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0adc
.L_lambda_simple_env_end_0adc:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0adc:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0adc
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0adc
.L_lambda_simple_params_end_0adc:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0adc
	jmp .L_lambda_simple_end_0adc
.L_lambda_simple_code_0adc:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0adc
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0adc:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param str
	push rax
	push 1	; arg count
	mov rax, qword [free_var_119]	; free var string->list
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_118]	; free var reverse
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_94]	; free var list->string
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f3c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f3c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f3c
.L_tc_recycle_frame_done_0f3c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0adc:	; new closure is in rax
	mov qword [free_var_129], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0add:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0add
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0add
.L_lambda_simple_env_end_0add:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0add:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0add
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0add
.L_lambda_simple_params_end_0add:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0add
	jmp .L_lambda_simple_end_0add
.L_lambda_simple_code_0add:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0add
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0add:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param vec
	push rax
	push 1	; arg count
	mov rax, qword [free_var_142]	; free var vector->list
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_118]	; free var reverse
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, qword [free_var_95]	; free var list->vector
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f3d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f3d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f3d
.L_tc_recycle_frame_done_0f3d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0add:	; new closure is in rax
	mov qword [free_var_146], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ade:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ade
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ade
.L_lambda_simple_env_end_0ade:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ade:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ade
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ade
.L_lambda_simple_params_end_0ade:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ade
	jmp .L_lambda_simple_end_0ade
.L_lambda_simple_code_0ade:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ade
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ade:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0adf:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0adf
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0adf
.L_lambda_simple_env_end_0adf:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0adf:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0adf
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0adf
.L_lambda_simple_params_end_0adf:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0adf
	jmp .L_lambda_simple_end_0adf
.L_lambda_simple_code_0adf:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0adf
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0adf:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param j
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0835
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param i
	push rax
	mov rax, PARAM(0)	; param str
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 3	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae0:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ae0
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae0
.L_lambda_simple_env_end_0ae0:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae0:	; copy params
	cmp rsi, 3
	je .L_lambda_simple_params_end_0ae0
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae0
.L_lambda_simple_params_end_0ae0:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae0
	jmp .L_lambda_simple_end_0ae0
.L_lambda_simple_code_0ae0:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ae0
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae0:
	enter 0, 0
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var j
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str
	push rax
	push 2	; arg count
	mov rax, qword [free_var_128]	; free var string-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var i
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str
	push rax
	push 3	; arg count
	mov rax, qword [free_var_131]	; free var string-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	; preparing a non-tail-call
	mov rax, PARAM(0)	; param ch
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var j
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str
	push rax
	push 3	; arg count
	mov rax, qword [free_var_131]	; free var string-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var j
	push rax
	push 2	; arg count
	mov rax, qword [free_var_2]	; free var -
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f3e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f3e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f3e
.L_tc_recycle_frame_done_0f3e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ae0:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f3f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f3f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f3f
.L_tc_recycle_frame_done_0f3f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0835
.L_if_else_0835:
	mov rax, PARAM(0)	; param str
.L_if_end_0835:
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0adf:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae1:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ae1
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae1
.L_lambda_simple_env_end_0ae1:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae1:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ae1
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae1
.L_lambda_simple_params_end_0ae1:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae1
	jmp .L_lambda_simple_end_0ae1
.L_lambda_simple_code_0ae1:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ae1
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae1:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param str
	push rax
	push 1	; arg count
	mov rax, qword [free_var_127]	; free var string-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae2:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ae2
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae2
.L_lambda_simple_env_end_0ae2:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae2:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ae2
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae2
.L_lambda_simple_params_end_0ae2:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae2
	jmp .L_lambda_simple_end_0ae2
.L_lambda_simple_code_0ae2:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ae2
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae2:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param n
	push rax
	push 1	; arg count
	mov rax, qword [free_var_152]	; free var zero?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0836
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str
	jmp .L_if_end_0836
.L_if_else_0836:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(0)	; param n
	push rax
	push 2	; arg count
	mov rax, qword [free_var_2]	; free var -
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, L_constants + 2135
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var str
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f40:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f40
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f40
.L_tc_recycle_frame_done_0f40:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_0836:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ae2:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f41:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f41
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f41
.L_tc_recycle_frame_done_0f41:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ae1:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ade:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_130], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae3:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ae3
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae3
.L_lambda_simple_env_end_0ae3:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae3:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ae3
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae3
.L_lambda_simple_params_end_0ae3:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae3
	jmp .L_lambda_simple_end_0ae3
.L_lambda_simple_code_0ae3:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ae3
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae3:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae4:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ae4
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae4
.L_lambda_simple_env_end_0ae4:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae4:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ae4
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae4
.L_lambda_simple_params_end_0ae4:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae4
	jmp .L_lambda_simple_end_0ae4
.L_lambda_simple_code_0ae4:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0ae4
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae4:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param j
	push rax
	mov rax, PARAM(1)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0837
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param i
	push rax
	mov rax, PARAM(0)	; param vec
	push rax
	push 2	; arg count
	mov rax, qword [free_var_145]	; free var vector-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 3	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae5:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ae5
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae5
.L_lambda_simple_env_end_0ae5:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae5:	; copy params
	cmp rsi, 3
	je .L_lambda_simple_params_end_0ae5
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae5
.L_lambda_simple_params_end_0ae5:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae5
	jmp .L_lambda_simple_end_0ae5
.L_lambda_simple_code_0ae5:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ae5
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae5:
	enter 0, 0
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var j
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var vec
	push rax
	push 2	; arg count
	mov rax, qword [free_var_145]	; free var vector-ref
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var i
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var vec
	push rax
	push 3	; arg count
	mov rax, qword [free_var_148]	; free var vector-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	; preparing a non-tail-call
	mov rax, PARAM(0)	; param ch
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var j
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var vec
	push rax
	push 3	; arg count
	mov rax, qword [free_var_148]	; free var vector-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var j
	push rax
	push 2	; arg count
	mov rax, qword [free_var_2]	; free var -
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var vec
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f42:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f42
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f42
.L_tc_recycle_frame_done_0f42:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ae5:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f43:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f43
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f43
.L_tc_recycle_frame_done_0f43:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0837
.L_if_else_0837:
	mov rax, PARAM(0)	; param vec
.L_if_end_0837:
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0ae4:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae6:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ae6
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae6
.L_lambda_simple_env_end_0ae6:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae6:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ae6
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae6
.L_lambda_simple_params_end_0ae6:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae6
	jmp .L_lambda_simple_end_0ae6
.L_lambda_simple_code_0ae6:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ae6
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae6:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param vec
	push rax
	push 1	; arg count
	mov rax, qword [free_var_144]	; free var vector-length
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae7:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0ae7
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae7
.L_lambda_simple_env_end_0ae7:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae7:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0ae7
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae7
.L_lambda_simple_params_end_0ae7:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae7
	jmp .L_lambda_simple_end_0ae7
.L_lambda_simple_code_0ae7:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ae7
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae7:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param n
	push rax
	push 1	; arg count
	mov rax, qword [free_var_152]	; free var zero?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0838
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var vec
	jmp .L_if_end_0838
.L_if_else_0838:
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(0)	; param n
	push rax
	push 2	; arg count
	mov rax, qword [free_var_2]	; free var -
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, L_constants + 2135
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var vec
	push rax
	push 3	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f44:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f44
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f44
.L_tc_recycle_frame_done_0f44:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_0838:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ae7:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f45:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f45
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f45
.L_tc_recycle_frame_done_0f45:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ae6:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ae3:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_147], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae8:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0ae8
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae8
.L_lambda_simple_env_end_0ae8:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae8:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0ae8
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae8
.L_lambda_simple_params_end_0ae8:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae8
	jmp .L_lambda_simple_end_0ae8
.L_lambda_simple_code_0ae8:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0ae8
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae8:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0ae9:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0ae9
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0ae9
.L_lambda_simple_env_end_0ae9:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0ae9:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0ae9
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0ae9
.L_lambda_simple_params_end_0ae9:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0ae9
	jmp .L_lambda_simple_end_0ae9
.L_lambda_simple_code_0ae9:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0ae9
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0ae9:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aea:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0aea
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aea
.L_lambda_simple_env_end_0aea:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aea:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aea
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aea
.L_lambda_simple_params_end_0aea:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aea
	jmp .L_lambda_simple_end_0aea
.L_lambda_simple_code_0aea:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aea
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aea:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var n
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_0839
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 1]	; bound var thunk
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_79]	; free var cons
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f46:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f46
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f46
.L_tc_recycle_frame_done_0f46:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_0839
.L_if_else_0839:
	mov rax, L_constants + 1
.L_if_end_0839:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aea:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	; preparing a tail-call
	mov rax, L_constants + 2135
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f47:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f47
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f47
.L_tc_recycle_frame_done_0f47:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0ae9:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f48:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f48
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f48
.L_tc_recycle_frame_done_0f48:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0ae8:	; new closure is in rax
	mov qword [free_var_98], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aeb:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0aeb
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aeb
.L_lambda_simple_env_end_0aeb:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aeb:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0aeb
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aeb
.L_lambda_simple_params_end_0aeb:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aeb
	jmp .L_lambda_simple_end_0aeb
.L_lambda_simple_code_0aeb:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0aeb
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aeb:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param n
	push rax
	push 1	; arg count
	mov rax, qword [free_var_99]	; free var make-string
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aec:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0aec
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aec
.L_lambda_simple_env_end_0aec:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aec:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0aec
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aec
.L_lambda_simple_params_end_0aec:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aec
	jmp .L_lambda_simple_end_0aec
.L_lambda_simple_code_0aec:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aec
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aec:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aed:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0aed
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aed
.L_lambda_simple_env_end_0aed:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aed:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aed
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aed
.L_lambda_simple_params_end_0aed:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aed
	jmp .L_lambda_simple_end_0aed
.L_lambda_simple_code_0aed:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aed
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aed:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aee:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0aee
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aee
.L_lambda_simple_env_end_0aee:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aee:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0aee
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aee
.L_lambda_simple_params_end_0aee:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aee
	jmp .L_lambda_simple_end_0aee
.L_lambda_simple_code_0aee:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0aee
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aee:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 2]
	mov rax, qword [rax + 8 * 0]	; bound var n
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_083a
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 2]
	mov rax, qword [rax + 8 * 1]	; bound var thunk
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var str
	push rax
	push 3	; arg count
	mov rax, qword [free_var_131]	; free var string-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f49:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f49
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f49
.L_tc_recycle_frame_done_0f49:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_083a
.L_if_else_083a:
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var str
.L_if_end_083a:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aee:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	; preparing a tail-call
	mov rax, L_constants + 2135
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f4a:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f4a
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f4a
.L_tc_recycle_frame_done_0f4a:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aed:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f4b:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f4b
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f4b
.L_tc_recycle_frame_done_0f4b:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0aec:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f4c:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f4c
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f4c
.L_tc_recycle_frame_done_0f4c:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0aeb:	; new closure is in rax
	mov qword [free_var_100], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0aef:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0aef
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0aef
.L_lambda_simple_env_end_0aef:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0aef:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0aef
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0aef
.L_lambda_simple_params_end_0aef:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0aef
	jmp .L_lambda_simple_end_0aef
.L_lambda_simple_code_0aef:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0aef
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0aef:
	enter 0, 0
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param n
	push rax
	push 1	; arg count
	mov rax, qword [free_var_101]	; free var make-vector
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af0:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0af0
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af0
.L_lambda_simple_env_end_0af0:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af0:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0af0
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af0
.L_lambda_simple_params_end_0af0:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af0
	jmp .L_lambda_simple_end_0af0
.L_lambda_simple_code_0af0:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0af0
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af0:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 1993
	push rax
	push 1	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 3	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af1:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 2
	je .L_lambda_simple_env_end_0af1
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af1
.L_lambda_simple_env_end_0af1:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af1:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0af1
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af1
.L_lambda_simple_params_end_0af1:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af1
	jmp .L_lambda_simple_end_0af1
.L_lambda_simple_code_0af1:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0af1
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af1:
	enter 0, 0
	mov rdi, 8*1
	call malloc
	mov rbx, PARAM(0)
	mov qword[rax], rbx
	mov PARAM(0), rax
	mov rax, sob_void

	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 1	; new rib
	call malloc
	push rax
	mov rdi, 8 * 4	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af2:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 3
	je .L_lambda_simple_env_end_0af2
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af2
.L_lambda_simple_env_end_0af2:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af2:	; copy params
	cmp rsi, 1
	je .L_lambda_simple_params_end_0af2
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af2
.L_lambda_simple_params_end_0af2:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af2
	jmp .L_lambda_simple_end_0af2
.L_lambda_simple_code_0af2:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0af2
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af2:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 2]
	mov rax, qword [rax + 8 * 0]	; bound var n
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_083b
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param i
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 2]
	mov rax, qword [rax + 8 * 1]	; bound var thunk
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var vec
	push rax
	push 3	; arg count
	mov rax, qword [free_var_148]	; free var vector-set!
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)

	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(0)	; param i
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 1	; arg count
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f4d:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f4d
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f4d
.L_tc_recycle_frame_done_0f4d:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_083b
.L_if_else_083b:
	mov rax, ENV
	mov rax, qword [rax + 8 * 1]
	mov rax, qword [rax + 8 * 0]	; bound var vec
.L_if_end_083b:
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0af2:	; new closure is in rax
	push rax
	mov rax, PARAM(0)	; param run
	pop qword [rax]
	mov rax, sob_void

	; preparing a tail-call
	mov rax, L_constants + 2135
	push rax
	push 1	; arg count
	mov rax, PARAM(0)	; param run
	mov rax, qword [rax]
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f4e:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f4e
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f4e
.L_tc_recycle_frame_done_0f4e:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0af1:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f4f:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f4f
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f4f
.L_tc_recycle_frame_done_0f4f:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0af0:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f50:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f50
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f50
.L_tc_recycle_frame_done_0f50:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0aef:	; new closure is in rax
	mov qword [free_var_102], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af3:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0af3
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af3
.L_lambda_simple_env_end_0af3:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af3:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0af3
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af3
.L_lambda_simple_params_end_0af3:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af3
	jmp .L_lambda_simple_end_0af3
.L_lambda_simple_code_0af3:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 3
	je .L_lambda_simple_arity_check_ok_0af3
	push qword [rsp + 8 * 2]
	push 3
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af3:
	enter 0, 0
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param n
	push rax
	push 1	; arg count
	mov rax, qword [free_var_152]	; free var zero?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_083e
	mov rax, L_constants + 3485
	jmp .L_if_end_083e
.L_if_else_083e:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_4]	; free var <
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_083d
	; preparing a tail-call
	; preparing a non-tail-call
	mov rax, PARAM(2)	; param n
	push rax
	; preparing a non-tail-call
	mov rax, PARAM(0)	; param a
	push rax
	mov rax, PARAM(1)	; param b
	push rax
	push 2	; arg count
	mov rax, qword [free_var_3]	; free var /
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 3	; arg count
	mov rax, qword [free_var_97]	; free var logarithm
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, L_constants + 3485
	push rax
	push 2	; arg count
	mov rax, qword [free_var_1]	; free var +
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f51:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f51
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f51
.L_tc_recycle_frame_done_0f51:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	jmp .L_if_end_083d
.L_if_else_083d:
	; preparing a non-tail-call
	mov rax, PARAM(1)	; param b
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	push 2	; arg count
	mov rax, qword [free_var_6]	; free var =
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp rax, sob_boolean_false
	je .L_if_else_083c
	mov rax, L_constants + 3485
	jmp .L_if_end_083c
.L_if_else_083c:
	; preparing a tail-call
	; preparing a non-tail-call
	; preparing a non-tail-call
	mov rax, L_constants + 2270
	push rax
	mov rax, PARAM(2)	; param n
	push rax
	push 2	; arg count
	mov rax, qword [free_var_2]	; free var -
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, PARAM(0)	; param a
	push rax
	mov rax, PARAM(1)	; param b
	push rax
	push 3	; arg count
	mov rax, qword [free_var_97]	; free var logarithm
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	mov rax, L_constants + 3485
	push rax
	push 2	; arg count
	mov rax, qword [free_var_3]	; free var /
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f52:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f52
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f52
.L_tc_recycle_frame_done_0f52:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
.L_if_end_083c:
.L_if_end_083d:
.L_if_end_083e:
	leave
	ret AND_KILL_FRAME(3)
.L_lambda_simple_end_0af3:	; new closure is in rax
	mov qword [free_var_97], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af4:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0af4
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af4
.L_lambda_simple_env_end_0af4:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af4:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0af4
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af4
.L_lambda_simple_params_end_0af4:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af4
	jmp .L_lambda_simple_end_0af4
.L_lambda_simple_code_0af4:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_simple_arity_check_ok_0af4
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af4:
	enter 0, 0
	; preparing a tail-call
	mov rax, L_constants + 3510
	push rax
	push 1	; arg count
	mov rax, qword [free_var_151]	; free var write-char
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f53:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f53
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f53
.L_tc_recycle_frame_done_0f53:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(0)
.L_lambda_simple_end_0af4:	; new closure is in rax
	mov qword [free_var_105], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af5:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0af5
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af5
.L_lambda_simple_env_end_0af5:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af5:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0af5
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af5
.L_lambda_simple_params_end_0af5:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af5
	jmp .L_lambda_simple_end_0af5
.L_lambda_simple_code_0af5:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_simple_arity_check_ok_0af5
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af5:
	enter 0, 0
	mov rax, L_constants + 0
	leave
	ret AND_KILL_FRAME(0)
.L_lambda_simple_end_0af5:	; new closure is in rax
	mov qword [free_var_150], rax
	mov rax, sob_void

	mov rdi, rax
	call print_sexpr_if_not_void
	; preparing a non-tail-call
	mov rax, L_constants + 3881
	push rax
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af6:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0af6
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af6
.L_lambda_simple_env_end_0af6:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af6:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0af6
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af6
.L_lambda_simple_params_end_0af6:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af6
	jmp .L_lambda_simple_end_0af6
.L_lambda_simple_code_0af6:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 10
	je .L_lambda_simple_arity_check_ok_0af6
	push qword [rsp + 8 * 2]
	push 10
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af6:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 10	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af7:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0af7
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af7
.L_lambda_simple_env_end_0af7:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af7:	; copy params
	cmp rsi, 10
	je .L_lambda_simple_params_end_0af7
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af7
.L_lambda_simple_params_end_0af7:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af7
	jmp .L_lambda_simple_end_0af7
.L_lambda_simple_code_0af7:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 1
	je .L_lambda_simple_arity_check_ok_0af7
	push qword [rsp + 8 * 2]
	push 1
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af7:
	enter 0, 0
	; preparing a tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var x1
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 9]	; bound var x10
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 8]	; bound var x9
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 7]	; bound var x8
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 6]	; bound var x7
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 5]	; bound var x6
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 4]	; bound var x5
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 3]	; bound var x4
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 2]	; bound var x3
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var x2
	push rax
	push 10	; arg count
	mov rax, PARAM(0)	; param z
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f54:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f54
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f54
.L_tc_recycle_frame_done_0f54:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(1)
.L_lambda_simple_end_0af7:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(10)
.L_lambda_simple_end_0af6:	; new closure is in rax
	push rax
	push 2	; arg count
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 0	; new rib
	call malloc
	push rax
	mov rdi, 8 * 1	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af8:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 0
	je .L_lambda_simple_env_end_0af8
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af8
.L_lambda_simple_env_end_0af8:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af8:	; copy params
	cmp rsi, 0
	je .L_lambda_simple_params_end_0af8
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af8
.L_lambda_simple_params_end_0af8:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af8
	jmp .L_lambda_simple_end_0af8
.L_lambda_simple_code_0af8:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 2
	je .L_lambda_simple_arity_check_ok_0af8
	push qword [rsp + 8 * 2]
	push 2
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af8:
	enter 0, 0
	mov rdi, (1 + 8 + 8)	; sob closure
	call malloc
	push rax
	mov rdi, 8 * 2	; new rib
	call malloc
	push rax
	mov rdi, 8 * 2	; extended env
	call malloc
	mov rdi, ENV
	mov rsi, 0
	mov rdx, 1
.L_lambda_simple_env_loop_0af9:	; ext_env[i + 1] <-- env[i]
	cmp rsi, 1
	je .L_lambda_simple_env_end_0af9
	mov rcx, qword [rdi + 8 * rsi]
	mov qword [rax + 8 * rdx], rcx
	inc rsi
	inc rdx
	jmp .L_lambda_simple_env_loop_0af9
.L_lambda_simple_env_end_0af9:
	pop rbx
	mov rsi, 0
.L_lambda_simple_params_loop_0af9:	; copy params
	cmp rsi, 2
	je .L_lambda_simple_params_end_0af9
	mov rdx, qword [rbp + 8 * rsi + 8 * 4]
	mov qword [rbx + 8 * rsi], rdx
	inc rsi
	jmp .L_lambda_simple_params_loop_0af9
.L_lambda_simple_params_end_0af9:
	mov qword [rax], rbx	; ext_env[0] <-- new_rib 
	mov rbx, rax
	pop rax
	mov byte [rax], T_closure
	mov SOB_CLOSURE_ENV(rax), rbx
	mov SOB_CLOSURE_CODE(rax), .L_lambda_simple_code_0af9
	jmp .L_lambda_simple_end_0af9
.L_lambda_simple_code_0af9:	; lambda-simple body
	cmp qword [rsp + 8 * 2], 0
	je .L_lambda_simple_arity_check_ok_0af9
	push qword [rsp + 8 * 2]
	push 0
	jmp L_error_incorrect_arity_simple
.L_lambda_simple_arity_check_ok_0af9:
	enter 0, 0
	; preparing a tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	; preparing a non-tail-call
	mov rax, qword [free_var_92]	; free var list
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 1	; arg count
	; preparing a non-tail-call
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 1]	; bound var s
	push rax
	mov rax, ENV
	mov rax, qword [rax + 8 * 0]
	mov rax, qword [rax + 8 * 0]	; bound var p1
	push rax
	push 2	; arg count
	mov rax, qword [free_var_33]	; free var apply
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	push rax
	push 2	; arg count
	mov rax, qword [free_var_81]	; free var equal?
	cmp byte [rax], T_undefined
	je L_error_fvar_undefined
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	push qword[rbp+ 8 * 1]	 ;old ret address of f
	push qword[rbp]
	mov r15, rbp	 ;will hold the rbp we need to overwrite
 	mov r14, qword[r15 + 3*8]	 ;r14 holding the param count of h
	add r14, 3 	 ;adding so we will get to the params 
	shl r14, 3 	 ;multiplie r14 by 8
	add r15, r14 	 ;now r15 points to the top of the rbp, An-1 
	mov r8, rsp 	; r8 now holds the lower of the stack
	mov r9, qword[rsp + 3*8] 	 ;r9 is holding the arg count of h
	add r9, 3 	 ;for getting to the params
	shl r9, 3 	 ;multiplie by 8 
	add r8, r9 	 ;now r8 is holding the top of rsp
.L_tc_recycle_frame_loop_0f55:
	cmp r8,rsp	 ;if we reached the end of the stack
	je .L_tc_recycle_frame_done_0f55
	mov rbx, qword[r8]	 ;rbx holds the value of the stack
	mov qword[r15], rbx	 ;move the value to the top of the stack
	sub r15, 8	 ;move the top of the stack one down
	sub r8, 8	 ;move the top of the stack one down
	jmp .L_tc_recycle_frame_loop_0f55
.L_tc_recycle_frame_done_0f55:
	pop rbp	 ;rbp now holding the old rbp of f
	lea rsp, [r15 + 8 *1]	 ;move the old rbp of f to the top of the stack
	jmp SOB_CLOSURE_CODE(rax)
	leave
	ret AND_KILL_FRAME(0)
.L_lambda_simple_end_0af9:	; new closure is in rax
	leave
	ret AND_KILL_FRAME(2)
.L_lambda_simple_end_0af8:	; new closure is in rax
	cmp byte [rax], T_closure
	jne L_error_non_closure
	push SOB_CLOSURE_ENV(rax)
	call SOB_CLOSURE_CODE(rax)
	mov qword [free_var_139], rax
	mov rax, sob_void
Lend:
	mov rdi, rax
	call print_sexpr_if_not_void

        mov rdi, fmt_memory_usage
        mov rsi, qword [top_of_memory]
        sub rsi, memory
        mov rax, 0
        ENTER
        call printf
        LEAVE
        mov rax, 0
        call exit

L_error_fvar_undefined:
        push rax
        mov rdi, qword [stderr]  ; destination
        mov rsi, fmt_undefined_free_var_1
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        pop rax
        mov rax, qword [rax + 1] ; string
        lea rdi, [rax + 1 + 8]   ; actual characters
        mov rsi, 1               ; sizeof(char)
        mov rdx, qword [rax + 1] ; string-length
        mov rcx, qword [stderr]  ; destination
        mov rax, 0
        ENTER
        call fwrite
        LEAVE
        mov rdi, [stderr]       ; destination
        mov rsi, fmt_undefined_free_var_2
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -10
        call exit

L_error_non_closure:
        mov rdi, qword [stderr]
        mov rsi, fmt_non_closure
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -2
        call exit

L_error_improper_list:
	mov rdi, qword [stderr]
	mov rsi, fmt_error_improper_list
	mov rax, 0
        ENTER
	call fprintf
        LEAVE
	mov rax, -7
	call exit

L_error_incorrect_arity_simple:
        mov rdi, qword [stderr]
        mov rsi, fmt_incorrect_arity_simple
        jmp L_error_incorrect_arity_common
L_error_incorrect_arity_opt:
        mov rdi, qword [stderr]
        mov rsi, fmt_incorrect_arity_opt
L_error_incorrect_arity_common:
        pop rdx
        pop rcx
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -6
        call exit

section .data
fmt_undefined_free_var_1:
        db `!!! The free variable \0`
fmt_undefined_free_var_2:
        db ` was used before it was defined.\n\0`
fmt_incorrect_arity_simple:
        db `!!! Expected %ld arguments, but given %ld\n\0`
fmt_incorrect_arity_opt:
        db `!!! Expected at least %ld arguments, but given %ld\n\0`
fmt_memory_usage:
        db `\n!!! Used %ld bytes of dynamically-allocated memory\n\n\0`
fmt_non_closure:
        db `!!! Attempting to apply a non-closure!\n\0`
fmt_error_improper_list:
	db `!!! The argument is not a proper list!\n\0`

section .bss
memory:
	resb gbytes(1)

section .data
top_of_memory:
        dq memory

section .text
malloc:
        mov rax, qword [top_of_memory]
        add qword [top_of_memory], rdi
        ret

L_code_ptr_return:
	cmp qword [rsp + 8*2], 2
	jne L_error_arg_count_2
	mov rcx, qword [rsp + 8*3]
	assert_integer(rcx)
	mov rcx, qword [rcx + 1]
	cmp rcx, 0
	jl L_error_integer_range
	mov rax, qword [rsp + 8*4]
.L0:
        cmp rcx, 0
        je .L1
	mov rbp, qword [rbp]
	dec rcx
	jg .L0
.L1:
	mov rsp, rbp
	pop rbp
        pop rbx
        mov rcx, qword [rsp + 8*1]
        lea rsp, [rsp + 8*rcx + 8*2]
	jmp rbx

L_code_ptr_make_list:
	enter 0, 0
        cmp COUNT, 1
        je .L0
        cmp COUNT, 2
        je .L1
        jmp L_error_arg_count_12
.L0:
        mov r9, sob_void
        jmp .L2
.L1:
        mov r9, PARAM(1)
.L2:
        mov rcx, PARAM(0)
        assert_integer(rcx)
        mov rcx, qword [rcx + 1]
        cmp rcx, 0
        jl L_error_arg_negative
        mov r8, sob_nil
.L3:
        cmp rcx, 0
        jle .L4
        mov rdi, 1 + 8 + 8
        call malloc
        mov byte [rax], T_pair
        mov qword [rax + 1], r9
        mov qword [rax + 1 + 8], r8
        mov r8, rax
        dec rcx
        jmp .L3
.L4:
        mov rax, r8
        cmp COUNT, 2
        je .L5
        leave
        ret AND_KILL_FRAME(1)
.L5:
	leave
	ret AND_KILL_FRAME(2)

L_code_ptr_is_primitive:
	enter 0, 0
	cmp COUNT, 1
	jne L_error_arg_count_1
	mov rax, PARAM(0)
	assert_closure(rax)
	cmp SOB_CLOSURE_ENV(rax), 0
	jne .L_false
	mov rax, sob_boolean_true
	jmp .L_end
.L_false:
	mov rax, sob_boolean_false
.L_end:
	leave
	ret AND_KILL_FRAME(1)

L_code_ptr_length:
	enter 0, 0
	cmp COUNT, 1
	jne L_error_arg_count_1
	mov rbx, PARAM(0)
	mov rdi, 0
.L:
	cmp byte [rbx], T_nil
	je .L_end
	assert_pair(rbx)
	mov rbx, SOB_PAIR_CDR(rbx)
	inc rdi
	jmp .L
.L_end:
	call make_integer
	leave
	ret AND_KILL_FRAME(1)

L_code_ptr_break:
        cmp qword [rsp + 8 * 2], 0
        jne L_error_arg_count_0
        int3
        mov rax, sob_void
        ret AND_KILL_FRAME(0)        

L_code_ptr_frame:
        enter 0, 0
        cmp COUNT, 0
        jne L_error_arg_count_0

        mov rdi, fmt_frame
        mov rsi, qword [rbp]    ; old rbp
        mov rdx, qword [rsi + 8*1] ; ret addr
        mov rcx, qword [rsi + 8*2] ; lexical environment
        mov r8, qword [rsi + 8*3] ; count
        lea r9, [rsi + 8*4]       ; address of argument 0
        push 0
        push r9
        push r8                   ; we'll use it when printing the params
        mov rax, 0
        
        ENTER
        call printf
        LEAVE

.L:
        mov rcx, qword [rsp]
        cmp rcx, 0
        je .L_out
        mov rdi, fmt_frame_param_prefix
        mov rsi, qword [rsp + 8*2]
        mov rax, 0
        
        ENTER
        call printf
        LEAVE

        mov rcx, qword [rsp]
        dec rcx
        mov qword [rsp], rcx    ; dec arg count
        inc qword [rsp + 8*2]   ; increment index of current arg
        mov rdi, qword [rsp + 8*1] ; addr of addr current arg
        lea r9, [rdi + 8]          ; addr of next arg
        mov qword [rsp + 8*1], r9  ; backup addr of next arg
        mov rdi, qword [rdi]       ; addr of current arg
        call print_sexpr
        mov rdi, fmt_newline
        mov rax, 0
        ENTER
        call printf
        LEAVE
        jmp .L
.L_out:
        mov rdi, fmt_frame_continue
        mov rax, 0
        ENTER
        call printf
        call getchar
        LEAVE
        
        mov rax, sob_void
        leave
        ret AND_KILL_FRAME(0)
        
print_sexpr_if_not_void:
	cmp rdi, sob_void
	je .done
	call print_sexpr
	mov rdi, fmt_newline
	mov rax, 0
	ENTER
	call printf
	LEAVE
.done:
	ret

section .data
fmt_frame:
        db `RBP = %p; ret addr = %p; lex env = %p; param count = %d\n\0`
fmt_frame_param_prefix:
        db `==[param %d]==> \0`
fmt_frame_continue:
        db `Hit <Enter> to continue...\0`
fmt_newline:
	db `\n\0`
fmt_void:
	db `#<void>\0`
fmt_nil:
	db `()\0`
fmt_boolean_false:
	db `#f\0`
fmt_boolean_true:
	db `#t\0`
fmt_char_backslash:
	db `#\\\\\0`
fmt_char_dquote:
	db `#\\"\0`
fmt_char_simple:
	db `#\\%c\0`
fmt_char_null:
	db `#\\nul\0`
fmt_char_bell:
	db `#\\bell\0`
fmt_char_backspace:
	db `#\\backspace\0`
fmt_char_tab:
	db `#\\tab\0`
fmt_char_newline:
	db `#\\newline\0`
fmt_char_formfeed:
	db `#\\page\0`
fmt_char_return:
	db `#\\return\0`
fmt_char_escape:
	db `#\\esc\0`
fmt_char_space:
	db `#\\space\0`
fmt_char_hex:
	db `#\\x%02X\0`
fmt_gensym:
        db `G%ld\0`
fmt_closure:
	db `#<closure at 0x%08X env=0x%08X code=0x%08X>\0`
fmt_lparen:
	db `(\0`
fmt_dotted_pair:
	db ` . \0`
fmt_rparen:
	db `)\0`
fmt_space:
	db ` \0`
fmt_empty_vector:
	db `#()\0`
fmt_vector:
	db `#(\0`
fmt_real:
	db `%f\0`
fmt_fraction:
	db `%ld/%ld\0`
fmt_zero:
	db `0\0`
fmt_int:
	db `%ld\0`
fmt_unknown_scheme_object_error:
	db `\n\n!!! Error: Unknown Scheme-object (RTTI 0x%02X) `
	db `at address 0x%08X\n\n\0`
fmt_dquote:
	db `\"\0`
fmt_string_char:
        db `%c\0`
fmt_string_char_7:
        db `\\a\0`
fmt_string_char_8:
        db `\\b\0`
fmt_string_char_9:
        db `\\t\0`
fmt_string_char_10:
        db `\\n\0`
fmt_string_char_11:
        db `\\v\0`
fmt_string_char_12:
        db `\\f\0`
fmt_string_char_13:
        db `\\r\0`
fmt_string_char_34:
        db `\\"\0`
fmt_string_char_92:
        db `\\\\\0`
fmt_string_char_hex:
        db `\\x%X;\0`

section .text

print_sexpr:
	enter 0, 0
	mov al, byte [rdi]
	cmp al, T_void
	je .Lvoid
	cmp al, T_nil
	je .Lnil
	cmp al, T_boolean_false
	je .Lboolean_false
	cmp al, T_boolean_true
	je .Lboolean_true
	cmp al, T_char
	je .Lchar
	cmp al, T_interned_symbol
	je .Linterned_symbol
        cmp al, T_uninterned_symbol
        je .Luninterned_symbol
	cmp al, T_pair
	je .Lpair
	cmp al, T_vector
	je .Lvector
	cmp al, T_closure
	je .Lclosure
	cmp al, T_real
	je .Lreal
	cmp al, T_fraction
	je .Lfraction
	cmp al, T_integer
	je .Linteger
	cmp al, T_string
	je .Lstring

	jmp .Lunknown_sexpr_type

.Lvoid:
	mov rdi, fmt_void
	jmp .Lemit

.Lnil:
	mov rdi, fmt_nil
	jmp .Lemit

.Lboolean_false:
	mov rdi, fmt_boolean_false
	jmp .Lemit

.Lboolean_true:
	mov rdi, fmt_boolean_true
	jmp .Lemit

.Lchar:
	mov al, byte [rdi + 1]
	cmp al, ' '
	jle .Lchar_whitespace
	cmp al, 92 		; backslash
	je .Lchar_backslash
	cmp al, '"'
	je .Lchar_dquote
	and rax, 255
	mov rdi, fmt_char_simple
	mov rsi, rax
	jmp .Lemit

.Lchar_whitespace:
	cmp al, 0
	je .Lchar_null
	cmp al, 7
	je .Lchar_bell
	cmp al, 8
	je .Lchar_backspace
	cmp al, 9
	je .Lchar_tab
	cmp al, 10
	je .Lchar_newline
	cmp al, 12
	je .Lchar_formfeed
	cmp al, 13
	je .Lchar_return
	cmp al, 27
	je .Lchar_escape
	and rax, 255
	cmp al, ' '
	je .Lchar_space
	mov rdi, fmt_char_hex
	mov rsi, rax
	jmp .Lemit	

.Lchar_backslash:
	mov rdi, fmt_char_backslash
	jmp .Lemit

.Lchar_dquote:
	mov rdi, fmt_char_dquote
	jmp .Lemit

.Lchar_null:
	mov rdi, fmt_char_null
	jmp .Lemit

.Lchar_bell:
	mov rdi, fmt_char_bell
	jmp .Lemit

.Lchar_backspace:
	mov rdi, fmt_char_backspace
	jmp .Lemit

.Lchar_tab:
	mov rdi, fmt_char_tab
	jmp .Lemit

.Lchar_newline:
	mov rdi, fmt_char_newline
	jmp .Lemit

.Lchar_formfeed:
	mov rdi, fmt_char_formfeed
	jmp .Lemit

.Lchar_return:
	mov rdi, fmt_char_return
	jmp .Lemit

.Lchar_escape:
	mov rdi, fmt_char_escape
	jmp .Lemit

.Lchar_space:
	mov rdi, fmt_char_space
	jmp .Lemit

.Lclosure:
	mov rsi, qword rdi
	mov rdi, fmt_closure
	mov rdx, SOB_CLOSURE_ENV(rsi)
	mov rcx, SOB_CLOSURE_CODE(rsi)
	jmp .Lemit

.Linterned_symbol:
	mov rdi, qword [rdi + 1] ; sob_string
	mov rsi, 1		 ; size = 1 byte
	mov rdx, qword [rdi + 1] ; length
	lea rdi, [rdi + 1 + 8]	 ; actual characters
	mov rcx, qword [stdout]	 ; FILE *
	ENTER
	call fwrite
	LEAVE
	jmp .Lend

.Luninterned_symbol:
        mov rsi, qword [rdi + 1] ; gensym counter
        mov rdi, fmt_gensym
        jmp .Lemit
	
.Lpair:
	push rdi
	mov rdi, fmt_lparen
	mov rax, 0
        ENTER
	call printf
        LEAVE
	mov rdi, qword [rsp] 	; pair
	mov rdi, SOB_PAIR_CAR(rdi)
	call print_sexpr
	pop rdi 		; pair
	mov rdi, SOB_PAIR_CDR(rdi)
.Lcdr:
	mov al, byte [rdi]
	cmp al, T_nil
	je .Lcdr_nil
	cmp al, T_pair
	je .Lcdr_pair
	push rdi
	mov rdi, fmt_dotted_pair
	mov rax, 0
        ENTER
	call printf
        LEAVE
	pop rdi
	call print_sexpr
	mov rdi, fmt_rparen
	mov rax, 0
        ENTER
	call printf
        LEAVE
	leave
	ret

.Lcdr_nil:
	mov rdi, fmt_rparen
	mov rax, 0
        ENTER
	call printf
        LEAVE
	leave
	ret

.Lcdr_pair:
	push rdi
	mov rdi, fmt_space
	mov rax, 0
        ENTER
	call printf
        LEAVE
	mov rdi, qword [rsp]
	mov rdi, SOB_PAIR_CAR(rdi)
	call print_sexpr
	pop rdi
	mov rdi, SOB_PAIR_CDR(rdi)
	jmp .Lcdr

.Lvector:
	mov rax, qword [rdi + 1] ; length
	cmp rax, 0
	je .Lvector_empty
	push rdi
	mov rdi, fmt_vector
	mov rax, 0
        ENTER
	call printf
        LEAVE
	mov rdi, qword [rsp]
	push qword [rdi + 1]
	push 1
	mov rdi, qword [rdi + 1 + 8] ; v[0]
	call print_sexpr
.Lvector_loop:
	; [rsp] index
	; [rsp + 8*1] limit
	; [rsp + 8*2] vector
	mov rax, qword [rsp]
	cmp rax, qword [rsp + 8*1]
	je .Lvector_end
	mov rdi, fmt_space
	mov rax, 0
        ENTER
	call printf
        LEAVE
	mov rax, qword [rsp]
	mov rbx, qword [rsp + 8*2]
	mov rdi, qword [rbx + 1 + 8 + 8 * rax] ; v[i]
	call print_sexpr
	inc qword [rsp]
	jmp .Lvector_loop

.Lvector_end:
	add rsp, 8*3
	mov rdi, fmt_rparen
	jmp .Lemit	

.Lvector_empty:
	mov rdi, fmt_empty_vector
	jmp .Lemit

.Lreal:
	push qword [rdi + 1]
	movsd xmm0, qword [rsp]
	add rsp, 8*1
	mov rdi, fmt_real
	mov rax, 1
	ENTER
	call printf
	LEAVE
	jmp .Lend

.Lfraction:
	mov rsi, qword [rdi + 1]
	mov rdx, qword [rdi + 1 + 8]
	cmp rsi, 0
	je .Lrat_zero
	cmp rdx, 1
	je .Lrat_int
	mov rdi, fmt_fraction
	jmp .Lemit

.Lrat_zero:
	mov rdi, fmt_zero
	jmp .Lemit

.Lrat_int:
	mov rdi, fmt_int
	jmp .Lemit

.Linteger:
	mov rsi, qword [rdi + 1]
	mov rdi, fmt_int
	jmp .Lemit

.Lstring:
	lea rax, [rdi + 1 + 8]
	push rax
	push qword [rdi + 1]
	mov rdi, fmt_dquote
	mov rax, 0
	ENTER
	call printf
	LEAVE
.Lstring_loop:
	; qword [rsp]: limit
	; qword [rsp + 8*1]: char *
	cmp qword [rsp], 0
	je .Lstring_end
	mov rax, qword [rsp + 8*1]
	mov al, byte [rax]
	and rax, 255
	cmp al, 7
        je .Lstring_char_7
        cmp al, 8
        je .Lstring_char_8
        cmp al, 9
        je .Lstring_char_9
        cmp al, 10
        je .Lstring_char_10
        cmp al, 11
        je .Lstring_char_11
        cmp al, 12
        je .Lstring_char_12
        cmp al, 13
        je .Lstring_char_13
        cmp al, 34
        je .Lstring_char_34
        cmp al, 92              ; \
        je .Lstring_char_92
        cmp al, ' '
        jl .Lstring_char_hex
        mov rdi, fmt_string_char
        mov rsi, rax
.Lstring_char_emit:
        mov rax, 0
        ENTER
        call printf
        LEAVE
        dec qword [rsp]
        inc qword [rsp + 8*1]
        jmp .Lstring_loop

.Lstring_char_7:
        mov rdi, fmt_string_char_7
        jmp .Lstring_char_emit

.Lstring_char_8:
        mov rdi, fmt_string_char_8
        jmp .Lstring_char_emit
        
.Lstring_char_9:
        mov rdi, fmt_string_char_9
        jmp .Lstring_char_emit

.Lstring_char_10:
        mov rdi, fmt_string_char_10
        jmp .Lstring_char_emit

.Lstring_char_11:
        mov rdi, fmt_string_char_11
        jmp .Lstring_char_emit

.Lstring_char_12:
        mov rdi, fmt_string_char_12
        jmp .Lstring_char_emit

.Lstring_char_13:
        mov rdi, fmt_string_char_13
        jmp .Lstring_char_emit

.Lstring_char_34:
        mov rdi, fmt_string_char_34
        jmp .Lstring_char_emit

.Lstring_char_92:
        mov rdi, fmt_string_char_92
        jmp .Lstring_char_emit

.Lstring_char_hex:
        mov rdi, fmt_string_char_hex
        mov rsi, rax
        jmp .Lstring_char_emit        

.Lstring_end:
	add rsp, 8 * 2
	mov rdi, fmt_dquote
	jmp .Lemit

.Lunknown_sexpr_type:
	mov rsi, fmt_unknown_scheme_object_error
	and rax, 255
	mov rdx, rax
	mov rcx, rdi
	mov rdi, qword [stderr]
	mov rax, 0
        ENTER
	call fprintf
        LEAVE
        leave
        ret

.Lemit:
	mov rax, 0
        ENTER
	call printf
        LEAVE
	jmp .Lend

.Lend:
	LEAVE
	ret

;;; rdi: address of free variable
;;; rsi: address of code-pointer
bind_primitive:
        enter 0, 0
        push rdi
        mov rdi, (1 + 8 + 8)
        call malloc
        pop rdi
        mov byte [rax], T_closure
        mov SOB_CLOSURE_ENV(rax), 0 ; dummy, lexical environment
        mov SOB_CLOSURE_CODE(rax), rsi ; code pointer
        mov qword [rdi], rax
        mov rax, sob_void
        leave
        ret

L_code_ptr_ash:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rdi, PARAM(0)
        assert_integer(rdi)
        mov rcx, PARAM(1)
        assert_integer(rcx)
        mov rdi, qword [rdi + 1]
        mov rcx, qword [rcx + 1]
        cmp rcx, 0
        jl .L_negative
.L_loop_positive:
        cmp rcx, 0
        je .L_exit
        sal rdi, cl
        shr rcx, 8
        jmp .L_loop_positive
.L_negative:
        neg rcx
.L_loop_negative:
        cmp rcx, 0
        je .L_exit
        sar rdi, cl
        shr rcx, 8
        jmp .L_loop_negative
.L_exit:
        call make_integer
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_logand:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov r8, PARAM(0)
        assert_integer(r8)
        mov r9, PARAM(1)
        assert_integer(r9)
        mov rdi, qword [r8 + 1]
        and rdi, qword [r9 + 1]
        call make_integer
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_logor:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov r8, PARAM(0)
        assert_integer(r8)
        mov r9, PARAM(1)
        assert_integer(r9)
        mov rdi, qword [r8 + 1]
        or rdi, qword [r9 + 1]
        call make_integer
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_logxor:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov r8, PARAM(0)
        assert_integer(r8)
        mov r9, PARAM(1)
        assert_integer(r9)
        mov rdi, qword [r8 + 1]
        xor rdi, qword [r9 + 1]
        call make_integer
        LEAVE
        ret AND_KILL_FRAME(2)

L_code_ptr_lognot:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov r8, PARAM(0)
        assert_integer(r8)
        mov rdi, qword [r8 + 1]
        not rdi
        call make_integer
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_bin_apply:
        enter 0, 0
        ;assuming we have 2 params - f and list to apply f on it
        mov rax, PARAM(0) ;save f
        mov rbx, PARAM(1) ;save s
        mov r10, qword [rbp] ;save old rbp
        mov r11, qword [rbp + 8 * 1] ;saving ret
        mov r12, SOB_CLOSURE_ENV(rax) ;saving env
        mov r8, 0 ;counter for list

.list_length_loop:
        cmp byte [rbx], T_nil ;while s!=null
        je .list_length_loop_end
        inc r8
        mov rbx, SOB_PAIR_CDR(rbx)
        jmp .list_length_loop

.list_length_loop_end:
        mov rbx, PARAM(1) ;restore s
        mov r15, r8 ;save list length
        sub r8, 2 ;the stack needs to keep the list, it's already have 2 params
        shl r8, 3 ;8 bytes for each param
        sub rbp, r8 ;allocating space for the list        
        mov r8, 0 ;counter for list


.copy_params_loop:
        cmp r8, r15
        je .copy_env_ret_rbp
        mov rcx, SOB_PAIR_CAR(rbx)
        mov qword[rbp + 8 * (4 + r8)], rcx
        mov rbx, SOB_PAIR_CDR(rbx)
        inc r8
        jmp .copy_params_loop

.copy_env_ret_rbp:
        mov qword[rbp], r10 ;in the end rbp points to the older rbp
        mov qword[rbp + 8 * 1], r11 ;restore ret
        mov qword[rbp + 8 * 2], r12 ;restore env
        mov qword[rbp + 8 * 3], r15 ;save list length
        mov rsp, r11 ;rsp points to the ret adress
        leave
        jmp SOB_CLOSURE_CODE(rax)

L_code_ptr_is_null:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_nil
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_pair:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_pair
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)
        
L_code_ptr_is_void:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_void
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_char:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_char
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_string:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_string
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_symbol:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov r8, PARAM(0)
        and byte [r8], T_symbol
        jz .L_false
        mov rax, sob_boolean_true
        jmp .L_exit
.L_false:
        mov rax, sob_boolean_false
.L_exit:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_uninterned_symbol:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov r8, PARAM(0)
        cmp byte [r8], T_uninterned_symbol
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_exit
.L_false:
        mov rax, sob_boolean_false
.L_exit:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_interned_symbol:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_interned_symbol
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_gensym:
        enter 0, 0
        cmp COUNT, 0
        jne L_error_arg_count_0
        inc qword [gensym_count]
        mov rdi, (1 + 8)
        call malloc
        mov byte [rax], T_uninterned_symbol
        mov rcx, qword [gensym_count]
        mov qword [rax + 1], rcx
        leave
        ret AND_KILL_FRAME(0)

L_code_ptr_is_vector:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_vector
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_closure:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_closure
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_real:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_real
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_fraction:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_fraction
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_boolean:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        mov bl, byte [rax]
        and bl, T_boolean
        je .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)
        
L_code_ptr_is_boolean_false:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        mov bl, byte [rax]
        cmp bl, T_boolean_false
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_boolean_true:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        mov bl, byte [rax]
        cmp bl, T_boolean_true
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_number:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        mov bl, byte [rax]
        and bl, T_number
        jz .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)
        
L_code_ptr_is_collection:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        mov bl, byte [rax]
        and bl, T_collection
        je .L_false
        mov rax, sob_boolean_true
        jmp .L_end
.L_false:
        mov rax, sob_boolean_false
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_cons:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rdi, (1 + 8 + 8)
        call malloc
        mov byte [rax], T_pair
        mov rbx, PARAM(0)
        mov SOB_PAIR_CAR(rax), rbx
        mov rbx, PARAM(1)
        mov SOB_PAIR_CDR(rax), rbx
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_display_sexpr:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rdi, PARAM(0)
        call print_sexpr
        mov rax, sob_void
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_write_char:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_char(rax)
        mov al, SOB_CHAR_VALUE(rax)
        and rax, 255
        mov rdi, fmt_char
        mov rsi, rax
        mov rax, 0
        ENTER
        call printf
        LEAVE
        mov rax, sob_void
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_car:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_pair(rax)
        mov rax, SOB_PAIR_CAR(rax)
        leave
        ret AND_KILL_FRAME(1)
        
L_code_ptr_cdr:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_pair(rax)
        mov rax, SOB_PAIR_CDR(rax)
        leave
        ret AND_KILL_FRAME(1)
        
L_code_ptr_string_length:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_string(rax)
        mov rdi, SOB_STRING_LENGTH(rax)
        call make_integer
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_vector_length:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_vector(rax)
        mov rdi, SOB_VECTOR_LENGTH(rax)
        call make_integer
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_real_to_integer:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rbx, PARAM(0)
        assert_real(rbx)
        movsd xmm0, qword [rbx + 1]
        cvttsd2si rdi, xmm0
        call make_integer
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_exit:
        enter 0, 0
        cmp COUNT, 0
        jne L_error_arg_count_0
        mov rax, 0
        call exit

L_code_ptr_integer_to_real:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_integer(rax)
        push qword [rax + 1]
        cvtsi2sd xmm0, qword [rsp]
        call make_real
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_fraction_to_real:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_fraction(rax)
        push qword [rax + 1]
        cvtsi2sd xmm0, qword [rsp]
        push qword [rax + 1 + 8]
        cvtsi2sd xmm1, qword [rsp]
        divsd xmm0, xmm1
        call make_real
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_char_to_integer:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_char(rax)
        mov al, byte [rax + 1]
        and rax, 255
        mov rdi, rax
        call make_integer
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_integer_to_fraction:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov r8, PARAM(0)
        assert_integer(r8)
        mov rdi, (1 + 8 + 8)
        call malloc
        mov rbx, qword [r8 + 1]
        mov byte [rax], T_fraction
        mov qword [rax + 1], rbx
        mov qword [rax + 1 + 8], 1
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_integer_to_char:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_integer(rax)
        mov rbx, qword [rax + 1]
        cmp rbx, 0
        jle L_error_integer_range
        cmp rbx, 256
        jge L_error_integer_range
        mov rdi, (1 + 1)
        call malloc
        mov byte [rax], T_char
        mov byte [rax + 1], bl
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_trng:
        enter 0, 0
        cmp COUNT, 0
        jne L_error_arg_count_0
        rdrand rdi
        shr rdi, 1
        call make_integer
        leave
        ret AND_KILL_FRAME(0)

L_code_ptr_is_zero:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_integer
        je .L_integer
        cmp byte [rax], T_fraction
        je .L_fraction
        cmp byte [rax], T_real
        je .L_real
        jmp L_error_incorrect_type
.L_integer:
        cmp qword [rax + 1], 0
        je .L_zero
        jmp .L_not_zero
.L_fraction:
        cmp qword [rax + 1], 0
        je .L_zero
        jmp .L_not_zero
.L_real:
        pxor xmm0, xmm0
        push qword [rax + 1]
        movsd xmm1, qword [rsp]
        ucomisd xmm0, xmm1
        je .L_zero
.L_not_zero:
        mov rax, sob_boolean_false
        jmp .L_end
.L_zero:
        mov rax, sob_boolean_true
.L_end:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_integer:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        cmp byte [rax], T_integer
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_exit
.L_false:
        mov rax, sob_boolean_false
.L_exit:
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_raw_bin_add_rr:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rbx, PARAM(0)
        assert_real(rbx)
        mov rcx, PARAM(1)
        assert_real(rcx)
        movsd xmm0, qword [rbx + 1]
        movsd xmm1, qword [rcx + 1]
        addsd xmm0, xmm1
        call make_real
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_sub_rr:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rbx, PARAM(0)
        assert_real(rbx)
        mov rcx, PARAM(1)
        assert_real(rcx)
        movsd xmm0, qword [rbx + 1]
        movsd xmm1, qword [rcx + 1]
        subsd xmm0, xmm1
        call make_real
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_mul_rr:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rbx, PARAM(0)
        assert_real(rbx)
        mov rcx, PARAM(1)
        assert_real(rcx)
        movsd xmm0, qword [rbx + 1]
        movsd xmm1, qword [rcx + 1]
        mulsd xmm0, xmm1
        call make_real
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_div_rr:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rbx, PARAM(0)
        assert_real(rbx)
        mov rcx, PARAM(1)
        assert_real(rcx)
        movsd xmm0, qword [rbx + 1]
        movsd xmm1, qword [rcx + 1]
        pxor xmm2, xmm2
        ucomisd xmm1, xmm2
        je L_error_division_by_zero
        divsd xmm0, xmm1
        call make_real
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_add_zz:
	enter 0, 0
	cmp COUNT, 2
	jne L_error_arg_count_2
	mov r8, PARAM(0)
	assert_integer(r8)
	mov r9, PARAM(1)
	assert_integer(r9)
	mov rdi, qword [r8 + 1]
	add rdi, qword [r9 + 1]
	call make_integer
	leave
	ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_add_qq:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov r8, PARAM(0)
        assert_fraction(r8)
        mov r9, PARAM(1)
        assert_fraction(r9)
        mov rax, qword [r8 + 1] ; num1
        mov rbx, qword [r9 + 1 + 8] ; den 2
        cqo
        imul rbx
        mov rsi, rax
        mov rax, qword [r8 + 1 + 8] ; den1
        mov rbx, qword [r9 + 1]     ; num2
        cqo
        imul rbx
        add rsi, rax
        mov rax, qword [r8 + 1 + 8] ; den1
        mov rbx, qword [r9 + 1 + 8] ; den2
        cqo
        imul rbx
        mov rdi, rax
        call normalize_fraction
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_sub_zz:
	enter 0, 0
	cmp COUNT, 2
	jne L_error_arg_count_2
	mov r8, PARAM(0)
	assert_integer(r8)
	mov r9, PARAM(1)
	assert_integer(r9)
	mov rdi, qword [r8 + 1]
	sub rdi, qword [r9 + 1]
	call make_integer
	leave
	ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_sub_qq:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov r8, PARAM(0)
        assert_fraction(r8)
        mov r9, PARAM(1)
        assert_fraction(r9)
        mov rax, qword [r8 + 1] ; num1
        mov rbx, qword [r9 + 1 + 8] ; den 2
        cqo
        imul rbx
        mov rsi, rax
        mov rax, qword [r8 + 1 + 8] ; den1
        mov rbx, qword [r9 + 1]     ; num2
        cqo
        imul rbx
        sub rsi, rax
        mov rax, qword [r8 + 1 + 8] ; den1
        mov rbx, qword [r9 + 1 + 8] ; den2
        cqo
        imul rbx
        mov rdi, rax
        call normalize_fraction
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_mul_zz:
	enter 0, 0
	cmp COUNT, 2
	jne L_error_arg_count_2
	mov r8, PARAM(0)
	assert_integer(r8)
	mov r9, PARAM(1)
	assert_integer(r9)
	cqo
	mov rax, qword [r8 + 1]
	mul qword [r9 + 1]
	mov rdi, rax
	call make_integer
	leave
	ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_mul_qq:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov r8, PARAM(0)
        assert_fraction(r8)
        mov r9, PARAM(1)
        assert_fraction(r9)
        mov rax, qword [r8 + 1] ; num1
        mov rbx, qword [r9 + 1] ; num2
        cqo
        imul rbx
        mov rsi, rax
        mov rax, qword [r8 + 1 + 8] ; den1
        mov rbx, qword [r9 + 1 + 8] ; den2
        cqo
        imul rbx
        mov rdi, rax
        call normalize_fraction
        leave
        ret AND_KILL_FRAME(2)
        
L_code_ptr_raw_bin_div_zz:
	enter 0, 0
	cmp COUNT, 2
	jne L_error_arg_count_2
	mov r8, PARAM(0)
	assert_integer(r8)
	mov r9, PARAM(1)
	assert_integer(r9)
	mov rdi, qword [r9 + 1]
	cmp rdi, 0
	je L_error_division_by_zero
	mov rsi, qword [r8 + 1]
	call normalize_fraction
	leave
	ret AND_KILL_FRAME(2)

L_code_ptr_raw_bin_div_qq:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov r8, PARAM(0)
        assert_fraction(r8)
        mov r9, PARAM(1)
        assert_fraction(r9)
        cmp qword [r9 + 1], 0
        je L_error_division_by_zero
        mov rax, qword [r8 + 1] ; num1
        mov rbx, qword [r9 + 1 + 8] ; den 2
        cqo
        imul rbx
        mov rsi, rax
        mov rax, qword [r8 + 1 + 8] ; den1
        mov rbx, qword [r9 + 1] ; num2
        cqo
        imul rbx
        mov rdi, rax
        call normalize_fraction
        leave
        ret AND_KILL_FRAME(2)
        
normalize_fraction:
        push rsi
        push rdi
        call gcd
        mov rbx, rax
        pop rax
        cqo
        idiv rbx
        mov r8, rax
        pop rax
        cqo
        idiv rbx
        mov r9, rax
        cmp r9, 0
        je .L_zero
        cmp r8, 1
        je .L_int
        mov rdi, (1 + 8 + 8)
        call malloc
        mov byte [rax], T_fraction
        mov qword [rax + 1], r9
        mov qword [rax + 1 + 8], r8
        ret
.L_zero:
        mov rdi, 0
        call make_integer
        ret
.L_int:
        mov rdi, r9
        call make_integer
        ret

iabs:
        mov rax, rdi
        cmp rax, 0
        jl .Lneg
        ret
.Lneg:
        neg rax
        ret

gcd:
        call iabs
        mov rbx, rax
        mov rdi, rsi
        call iabs
        cmp rax, 0
        jne .L0
        xchg rax, rbx
.L0:
        cmp rbx, 0
        je .L1
        cqo
        div rbx
        mov rax, rdx
        xchg rax, rbx
        jmp .L0
.L1:
        ret

L_code_ptr_error:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rsi, PARAM(0)
        assert_interned_symbol(rsi)
        mov rsi, PARAM(1)
        assert_string(rsi)
        mov rdi, fmt_scheme_error_part_1
        mov rax, 0
        ENTER
        call printf
        LEAVE
        mov rdi, PARAM(0)
        call print_sexpr
        mov rdi, fmt_scheme_error_part_2
        mov rax, 0
        ENTER
        call printf
        LEAVE
        mov rax, PARAM(1)       ; sob_string
        mov rsi, 1              ; size = 1 byte
        mov rdx, qword [rax + 1] ; length
        lea rdi, [rax + 1 + 8]   ; actual characters
        mov rcx, qword [stdout]  ; FILE*
	ENTER
        call fwrite
	LEAVE
        mov rdi, fmt_scheme_error_part_3
        mov rax, 0
        ENTER
        call printf
        LEAVE
        mov rax, -9
        call exit

L_code_ptr_raw_less_than_rr:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rsi, PARAM(0)
        assert_real(rsi)
        mov rdi, PARAM(1)
        assert_real(rdi)
        movsd xmm0, qword [rsi + 1]
        movsd xmm1, qword [rdi + 1]
        comisd xmm0, xmm1
        jae .L_false
        mov rax, sob_boolean_true
        jmp .L_exit
.L_false:
        mov rax, sob_boolean_false
.L_exit:
        leave
        ret AND_KILL_FRAME(2)
        
L_code_ptr_raw_less_than_zz:
	enter 0, 0
	cmp COUNT, 2
	jne L_error_arg_count_2
	mov r8, PARAM(0)
	assert_integer(r8)
	mov r9, PARAM(1)
	assert_integer(r9)
	mov rdi, qword [r8 + 1]
	cmp rdi, qword [r9 + 1]
	jge .L_false
	mov rax, sob_boolean_true
	jmp .L_exit
.L_false:
	mov rax, sob_boolean_false
.L_exit:
	leave
	ret AND_KILL_FRAME(2)

L_code_ptr_raw_less_than_qq:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rsi, PARAM(0)
        assert_fraction(rsi)
        mov rdi, PARAM(1)
        assert_fraction(rdi)
        mov rax, qword [rsi + 1] ; num1
        cqo
        imul qword [rdi + 1 + 8] ; den2
        mov rcx, rax
        mov rax, qword [rsi + 1 + 8] ; den1
        cqo
        imul qword [rdi + 1]          ; num2
        sub rcx, rax
        jge .L_false
        mov rax, sob_boolean_true
        jmp .L_exit
.L_false:
        mov rax, sob_boolean_false
.L_exit:
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_raw_equal_rr:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rsi, PARAM(0)
        assert_real(rsi)
        mov rdi, PARAM(1)
        assert_real(rdi)
        movsd xmm0, qword [rsi + 1]
        movsd xmm1, qword [rdi + 1]
        comisd xmm0, xmm1
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_exit
.L_false:
        mov rax, sob_boolean_false
.L_exit:
        leave
        ret AND_KILL_FRAME(2)
        
L_code_ptr_raw_equal_zz:
	enter 0, 0
	cmp COUNT, 2
	jne L_error_arg_count_2
	mov r8, PARAM(0)
	assert_integer(r8)
	mov r9, PARAM(1)
	assert_integer(r9)
	mov rdi, qword [r8 + 1]
	cmp rdi, qword [r9 + 1]
	jne .L_false
	mov rax, sob_boolean_true
	jmp .L_exit
.L_false:
	mov rax, sob_boolean_false
.L_exit:
	leave
	ret AND_KILL_FRAME(2)

L_code_ptr_raw_equal_qq:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rsi, PARAM(0)
        assert_fraction(rsi)
        mov rdi, PARAM(1)
        assert_fraction(rdi)
        mov rax, qword [rsi + 1] ; num1
        cqo
        imul qword [rdi + 1 + 8] ; den2
        mov rcx, rax
        mov rax, qword [rdi + 1 + 8] ; den1
        cqo
        imul qword [rdi + 1]          ; num2
        sub rcx, rax
        jne .L_false
        mov rax, sob_boolean_true
        jmp .L_exit
.L_false:
        mov rax, sob_boolean_false
.L_exit:
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_quotient:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rsi, PARAM(0)
        assert_integer(rsi)
        mov rdi, PARAM(1)
        assert_integer(rdi)
        mov rax, qword [rsi + 1]
        mov rbx, qword [rdi + 1]
        cmp rbx, 0
        je L_error_division_by_zero
        cqo
        idiv rbx
        mov rdi, rax
        call make_integer
        leave
        ret AND_KILL_FRAME(2)
        
L_code_ptr_remainder:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rsi, PARAM(0)
        assert_integer(rsi)
        mov rdi, PARAM(1)
        assert_integer(rdi)
        mov rax, qword [rsi + 1]
        mov rbx, qword [rdi + 1]
        cmp rbx, 0
        je L_error_division_by_zero
        cqo
        idiv rbx
        mov rdi, rdx
        call make_integer
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_set_car:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rax, PARAM(0)
        assert_pair(rax)
        mov rbx, PARAM(1)
        mov SOB_PAIR_CAR(rax), rbx
        mov rax, sob_void
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_set_cdr:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rax, PARAM(0)
        assert_pair(rax)
        mov rbx, PARAM(1)
        mov SOB_PAIR_CDR(rax), rbx
        mov rax, sob_void
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_string_ref:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rdi, PARAM(0)
        assert_string(rdi)
        mov rsi, PARAM(1)
        assert_integer(rsi)
        mov rdx, qword [rdi + 1]
        mov rcx, qword [rsi + 1]
        cmp rcx, rdx
        jge L_error_integer_range
        cmp rcx, 0
        jl L_error_integer_range
        mov bl, byte [rdi + 1 + 8 + 1 * rcx]
        mov rdi, 2
        call malloc
        mov byte [rax], T_char
        mov byte [rax + 1], bl
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_vector_ref:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rdi, PARAM(0)
        assert_vector(rdi)
        mov rsi, PARAM(1)
        assert_integer(rsi)
        mov rdx, qword [rdi + 1]
        mov rcx, qword [rsi + 1]
        cmp rcx, rdx
        jge L_error_integer_range
        cmp rcx, 0
        jl L_error_integer_range
        mov rax, [rdi + 1 + 8 + 8 * rcx]
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_vector_set:
        enter 0, 0
        cmp COUNT, 3
        jne L_error_arg_count_3
        mov rdi, PARAM(0)
        assert_vector(rdi)
        mov rsi, PARAM(1)
        assert_integer(rsi)
        mov rdx, qword [rdi + 1]
        mov rcx, qword [rsi + 1]
        cmp rcx, rdx
        jge L_error_integer_range
        cmp rcx, 0
        jl L_error_integer_range
        mov rax, PARAM(2)
        mov qword [rdi + 1 + 8 + 8 * rcx], rax
        mov rax, sob_void
        leave
        ret AND_KILL_FRAME(3)

L_code_ptr_string_set:
        enter 0, 0
        cmp COUNT, 3
        jne L_error_arg_count_3
        mov rdi, PARAM(0)
        assert_string(rdi)
        mov rsi, PARAM(1)
        assert_integer(rsi)
        mov rdx, qword [rdi + 1]
        mov rcx, qword [rsi + 1]
        cmp rcx, rdx
        jge L_error_integer_range
        cmp rcx, 0
        jl L_error_integer_range
        mov rax, PARAM(2)
        assert_char(rax)
        mov al, byte [rax + 1]
        mov byte [rdi + 1 + 8 + 1 * rcx], al
        mov rax, sob_void
        leave
        ret AND_KILL_FRAME(3)

L_code_ptr_make_vector:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rcx, PARAM(0)
        assert_integer(rcx)
        mov rcx, qword [rcx + 1]
        cmp rcx, 0
        jl L_error_integer_range
        mov rdx, PARAM(1)
        lea rdi, [1 + 8 + 8 * rcx]
        call malloc
        mov byte [rax], T_vector
        mov qword [rax + 1], rcx
        mov r8, 0
.L0:
        cmp r8, rcx
        je .L1
        mov qword [rax + 1 + 8 + 8 * r8], rdx
        inc r8
        jmp .L0
.L1:
        leave
        ret AND_KILL_FRAME(2)
        
L_code_ptr_make_string:
        enter 0, 0
        cmp COUNT, 2
        jne L_error_arg_count_2
        mov rcx, PARAM(0)
        assert_integer(rcx)
        mov rcx, qword [rcx + 1]
        cmp rcx, 0
        jl L_error_integer_range
        mov rdx, PARAM(1)
        assert_char(rdx)
        mov dl, byte [rdx + 1]
        lea rdi, [1 + 8 + 1 * rcx]
        call malloc
        mov byte [rax], T_string
        mov qword [rax + 1], rcx
        mov r8, 0
.L0:
        cmp r8, rcx
        je .L1
        mov byte [rax + 1 + 8 + 1 * r8], dl
        inc r8
        jmp .L0
.L1:
        leave
        ret AND_KILL_FRAME(2)

L_code_ptr_numerator:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_fraction(rax)
        mov rdi, qword [rax + 1]
        call make_integer
        leave
        ret AND_KILL_FRAME(1)
        
L_code_ptr_denominator:
        enter 0, 0
        cmp COUNT, 1
        jne L_error_arg_count_1
        mov rax, PARAM(0)
        assert_fraction(rax)
        mov rdi, qword [rax + 1 + 8]
        call make_integer
        leave
        ret AND_KILL_FRAME(1)

L_code_ptr_is_eq:
	enter 0, 0
	cmp COUNT, 2
	jne L_error_arg_count_2
	mov rdi, PARAM(0)
	mov rsi, PARAM(1)
	cmp rdi, rsi
	je .L_eq_true
	mov dl, byte [rdi]
	cmp dl, byte [rsi]
	jne .L_eq_false
	cmp dl, T_char
	je .L_char
	cmp dl, T_interned_symbol
	je .L_interned_symbol
        cmp dl, T_uninterned_symbol
        je .L_uninterned_symbol
	cmp dl, T_real
	je .L_real
	cmp dl, T_fraction
	je .L_fraction
        cmp dl, T_integer
        je .L_integer
	jmp .L_eq_false
.L_integer:
        mov rax, qword [rsi + 1]
        cmp rax, qword [rdi + 1]
        jne .L_eq_false
        jmp .L_eq_true
.L_fraction:
	mov rax, qword [rsi + 1]
	cmp rax, qword [rdi + 1]
	jne .L_eq_false
	mov rax, qword [rsi + 1 + 8]
	cmp rax, qword [rdi + 1 + 8]
	jne .L_eq_false
	jmp .L_eq_true
.L_real:
	mov rax, qword [rsi + 1]
	cmp rax, qword [rdi + 1]
.L_interned_symbol:
	; never reached, because interned_symbols are static!
	; but I'm keeping it in case, I'll ever change
	; the implementation
	mov rax, qword [rsi + 1]
	cmp rax, qword [rdi + 1]
.L_uninterned_symbol:
        mov r8, qword [rdi + 1]
        cmp r8, qword [rsi + 1]
        jne .L_eq_false
        jmp .L_eq_true
.L_char:
	mov bl, byte [rsi + 1]
	cmp bl, byte [rdi + 1]
	jne .L_eq_false
.L_eq_true:
	mov rax, sob_boolean_true
	jmp .L_eq_exit
.L_eq_false:
	mov rax, sob_boolean_false
.L_eq_exit:
	leave
	ret AND_KILL_FRAME(2)

make_real:
        enter 0, 0
        mov rdi, (1 + 8)
        call malloc
        mov byte [rax], T_real
        movsd qword [rax + 1], xmm0
        leave 
        ret
        
make_integer:
        enter 0, 0
        mov rsi, rdi
        mov rdi, (1 + 8)
        call malloc
        mov byte [rax], T_integer
        mov qword [rax + 1], rsi
        leave
        ret
        
L_error_integer_range:
        mov rdi, qword [stderr]
        mov rsi, fmt_integer_range
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -5
        call exit

L_error_arg_negative:
        mov rdi, qword [stderr]
        mov rsi, fmt_arg_negative
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -3
        call exit

L_error_arg_count_0:
        mov rdi, qword [stderr]
        mov rsi, fmt_arg_count_0
        mov rdx, COUNT
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -3
        call exit

L_error_arg_count_1:
        mov rdi, qword [stderr]
        mov rsi, fmt_arg_count_1
        mov rdx, COUNT
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -3
        call exit

L_error_arg_count_2:
        mov rdi, qword [stderr]
        mov rsi, fmt_arg_count_2
        mov rdx, COUNT
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -3
        call exit

L_error_arg_count_12:
        mov rdi, qword [stderr]
        mov rsi, fmt_arg_count_12
        mov rdx, COUNT
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -3
        call exit

L_error_arg_count_3:
        mov rdi, qword [stderr]
        mov rsi, fmt_arg_count_3
        mov rdx, COUNT
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -3
        call exit
        
L_error_incorrect_type:
        mov rdi, qword [stderr]
        mov rsi, fmt_type
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -4
        call exit

L_error_division_by_zero:
        mov rdi, qword [stderr]
        mov rsi, fmt_division_by_zero
        mov rax, 0
        ENTER
        call fprintf
        LEAVE
        mov rax, -8
        call exit

section .data
gensym_count:
        dq 0
fmt_char:
        db `%c\0`
fmt_arg_negative:
        db `!!! The argument cannot be negative.\n\0`
fmt_arg_count_0:
        db `!!! Expecting zero arguments. Found %d\n\0`
fmt_arg_count_1:
        db `!!! Expecting one argument. Found %d\n\0`
fmt_arg_count_12:
        db `!!! Expecting one required and one optional argument. Found %d\n\0`
fmt_arg_count_2:
        db `!!! Expecting two arguments. Found %d\n\0`
fmt_arg_count_3:
        db `!!! Expecting three arguments. Found %d\n\0`
fmt_type:
        db `!!! Function passed incorrect type\n\0`
fmt_integer_range:
        db `!!! Incorrect integer range\n\0`
fmt_division_by_zero:
        db `!!! Division by zero\n\0`
fmt_scheme_error_part_1:
        db `\n!!! The procedure \0`
fmt_scheme_error_part_2:
        db ` asked to terminate the program\n`
        db `    with the following message:\n\n\0`
fmt_scheme_error_part_3:
        db `\n\nGoodbye!\n\n\0`
